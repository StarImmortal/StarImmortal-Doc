---
title: Java
---

# 基础篇

## 面向对象

### 什么是面向对象

#### 面向对象与面向过程

- #### 什么是面向过程？

  **概述: 自顶而下的编程模式**

  把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。

  就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。

  最典型的用法就是实现一个简单的算法，比如实现冒泡排序。

- 什么是面向对象？

  **概述: 将事务高度抽象化的编程模式**

  将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。

  就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。

  比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。

- 举例说明区别

  同样一个象棋设计：

  面向对象：创建黑白双方的对象负责演算，棋盘的对象负责画布，规则的对象负责判断，例子可以看出,面向对象更重视不重复造轮子，即创建一次，重复使用。

  面向过程：开始—黑走—棋盘—判断—白走—棋盘—判断—循环。只需要关注每一步怎么实现即可。

- 优劣对比

  面向对象：占用资源相对高，速度相对慢

  面向过程：占用资源相对低，速度相对快

#### 面向对象的三大基本特征

- **封装(Encapsulation)**

  所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  
  封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

- **继承(Inheritance)**

  继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
  
  通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。
  
  继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

- **多态(Polymorphism)**

  所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

  最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

#### 面向对象的五大基本原则

- **单一职责原则（Single-Responsibility Principle）**

  其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。
  
  单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
  
  职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。
  
  通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。

  专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。

- **开放封闭原则（Open-Closed principle）**

  其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

  开放封闭原则主要体现在两个方面：

  1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

  2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

  实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。

  “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。

- **Liskov替换原则（Liskov-Substitution Principle）**

  其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。
  
  在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。

  Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。
  
  实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。

  Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

- **依赖倒置原则（Dependecy-Inversion Principle）**

  其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
  
  我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。
  
  抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

- **接口隔离原则（Interface-Segregation Principle）**

  其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。
  
  具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。
  
  接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 

  分离的手段主要有以下两种：

  1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。

  2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

  以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”

### 封装、继承、多态

#### 什么是多态

- **什么是多态？**

  同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

  如果按照这个概念来定义的话，那么多态应该是一种运行期的状态。

- **多态的必要条件**

  为了实现运行期的多态，或者说是动态绑定，需要满足三个条件。

  即有类继承或者接口实现、子类要重写父类的方法、父类的引用指向子类的对象。

  示例代码：

  ```java
  public class Parent{
      public void call(){
          System.out.println("I am parent");
      }
  }
  
  public class Son extends Parent{// 1.有类继承或者接口实现
      @Override
      public void call(){// 2.子类要重写父类的方法
          System.out.println("I am son");
      }
  }
  
  public class Daughter extends Parent{// 1.有类继承或者接口实现
      @Override
      public void call(){// 2.子类要重写父类的方法
          System.out.println("I am daughter");
      }
  }
  
  public class Test{
      public static void main(String[] args){
          Parent p = new Son(); //3.父类的引用指向子类的对象
          Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
      }
  }
  ```

  这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。

  有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的啊。

  比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁，根据具体情况而定。

  另外，还有一种说法，包括维基百科也说明，多态还分为动态多态和静态多态。

  上面提到的那种动态绑定认为是动态多态，因为只有在运行期才能知道真正调用的是哪个类的方法。

  还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法。

  关于这个动态静态的说法，我更偏向于重载和多态其实是无关的。

  但是也要看情况，普通场合，我会认为只有方法的重写算是多态，毕竟这是我的观点。但是如果在面试的时候，我“可能”会认为重载也算是多态，毕竟面试官也有他的观点。我会和面试官说：我认为，多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。

#### 方法重写与重载

- **定义**

  1. 重载

    简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

  2. 重写

    重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

- **重载VS重写**

  1. 重载是一个编译期概念、重写是一个运行期间概念。
  2. 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
  3. 重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。
  4. 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

- **重写的例子**

  ```java
  class Dog {
      public void bark() {
          System.out.println("woof");
      }
  }
  
  class Hound extends Dog {
      public void sniff() {
          System.out.println("sniff");
      }
  	
      @Override
      public void bark() {
          System.out.println("bowl");
      }
  }
  
  public class OverridingTest {
      public static void main(String [] args) {
          Dog dog = new Hound();
          dog.bark();
      }
  }
  ```

  输出结果：

  ```java
  bowl
  ```

  上面的例子中，`dog`对象被定义为`Dog`类型。

  在编译期，编译器会检查Dog类中是否有可访问的`bark()`方法，只要其中包含`bark()`方法，那么就可以编译通过。

  在运行期，`Hound`对象被`new`出来，并赋值给`dog`变量，这时，JVM是明确的知道`dog`变量指向的其实是`Hound`对象的引用。

  所以，当`dog`调用`bark()`方法的时候，就会调用`Hound`类中定义的`bark()`方法。这就是所谓的动态多态性。

- **重写的条件**
  
  :::tip
  列表必须完全与被重写方法的相同
  
  返回类型必须完全与被重写方法的返回类型相同
  
  访问级别的限制性一定不能比被重写方法的强
  
  访问级别的限制性可以比被重写方法的弱
  
  重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
  
  重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
  
  不能重写被标示为final的方法
  
  如果不能继承一个方法，则不能重写这个方法
  :::

- **重载的例子**

  ```java
  class Dog {
      public void bark() {
          System.out.println("woof");
      }
  
      //overloading method
      public void bark(int num) {
          for (int i = 0; i < num; i++) {
              System.out.println("woof");
          }
      }
  }
  ```

  上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。

  在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。

- **重载的条件**

  :::tip
  被重载的方法必须改变参数列
  
  被重载的方法可以改变返回类型
  
  被重载的方法可以改变访问修饰符
  
  被重载的方法可以声明新的或更广的检查异常
  
  方法能够在同一个类中或者在一个子类中被重载
  :::

- **参考资料**

  [Overriding vs. Overloading in Java](https://www.programcreek.com/2009/02/overriding-and-overloading-in-java-with-example )

#### Java 的继承与实现

面向对象有三个特征：封装、继承、多态。

其中继承和实现都体现了`传递性`。而且明确定义如下：

继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。

实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标

所以，继承的根本原因是因为要*复用*，而实现的根本原因是需要定义一个*标准*。

在Java中，继承使用`extends`关键字实现，而实现通过`implements`关键字。

Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。

简单点说，就是同样是一台汽车，既可以是电动车，也可以是汽油车，也可以是油电混合的，只要实现不同的标准就行了，但是一台车只能属于一个品牌，一个厂商。

```java
class Car extends Benz implements GasolineCar, ElectroCar {

}
```

在接口中只能定义全局常量（static final）和无实现的方法（Java 8以后可以有defult方法）；而在继承中可以定义属性方法、变量、常量等。

#### Java 的继承与组合

- **面向对象的复用技术**

  复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。

  作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。

- **继承**

  继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种[`is-a`](https://zh.wikipedia.org/wiki/Is-a)关系。

  <img src="https://s1.ax1x.com/2020/10/13/04CBMd.png" />

- **组合**

  组合(Composition)体现的是整体与部分、拥有的关系，即[`has-a`](https://en.wikipedia.org/wiki/Has-a)的关系。

  <img src="http://www.hollischuang.com/wp-content/uploads/2016/03/Composition.jpg" />

- **组合与继承的区别和联系**

  在`继承`结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种`白盒式代码复用`。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）
  
  `组合`是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是`黑盒式代码复用`。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）
  
  `继承`，在写代码的时候就要指名具体继承哪个类，所以，在`编译期`就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）
  
  `组合`，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在`运行期`确定。

- **优缺点对比**

  | 组 合 关 系                                                  | 继 承 关 系                                                  |
  | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立     | 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 |
  | 优点：具有较好的可扩展性                                     | 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价         |
  | 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 | 缺点：不支持动态继承。在运行时，子类无法选择不同的父类       |
  | 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 | 缺点：子类不能改变父类的接口                                 |
  | 缺点：整体类不能自动获得和局部类同样的接口                   | 优点：子类能自动继承父类的接口                               |
  | 缺点：创建整体类的对象时，需要创建所有局部类的对象           | 优点：创建子类的对象时，无须创建父类的对象                   |

- **如何选择**

  相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。

  所以：

  > **`建议在同样可行的情况下，优先使用组合而不是继承。`**
  >
  > **`因为组合更安全，更简单，更灵活，更高效。`**

  注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。

  继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。《[Java编程思想](http://s.click.taobao.com/t?e=m%3D2%26s%3DHzJzud6zOdocQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67vo5P8BMUBgoEC56fBbgyn5pS4hLH%2FP02ckKYNRBWOBBey11vvWwHXSniyi5vWXIZhtlrJbLMDAQihpQCXu2JnPFYKQlNeOGCsYMXU3NNCg%2F&pvid=10_125.119.86.125_222_1458652212179)》
  
  只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在[`is-a`](https://zh.wikipedia.org/wiki/Is-a)关系的时候，类B才应该继承类A。《[Effective Java](http://s.click.taobao.com/t?e=m%3D2%26s%3DwIPn8%2BNPqLwcQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67vo5P8BMUBgoUOZr0mLjusdpS4hLH%2FP02ckKYNRBWOBBey11vvWwHXSniyi5vWXIZvgXwmdyquYbNLnO%2BjzYQLqKnzbV%2FMLqnMYMXU3NNCg%2F&pvid=10_125.119.86.125_345_1458652241780)》

#### super 与 this 关键字

- **this 关键字**

  this 关键字代表的是对象的引用，也就是this在指向一个对象，所指向的对象就是调用该函数的对象引用

  **关键用法**

  > 在本类的成员方法中，访问本类的成员变量
  >
  > 在本类的成员方法中，访问本类的另一个成员方法
  >
  > 在本类的构造方法中，访问本类的另一个构造方法
  
  **this 关键字可以出现在类方法中吗？**
  
  不可以，类方法（静态方法）是属于类级别的，为所有对象共有的，在类加载进内存的时候就存在了，此时还没有对象，this就无法指向任何对象。
  
- **super 关键字**

  super 关键字主要存在于子类方法中，用于指向子类对象中父类对象。在子类的构造函数中，如果没有显式调用`super`来初始化父类的话，那么Java会隐式的调用`super()`来调用父类无参构造函数并把它放在构造函数的第一行。Java只会隐式的调用无参构造函数，如果父类没有无参构造函数，那么子类中就必须显示的调用super关键字来调用已有的有参构造函数来初始化父类。

  **关键用法**

  > 在子类的成员方法中，访问父类的成员变量
  >
  > 在子类的成员方法中，访问父类的成员方法
  >
  > 在子类的构造方法中，访问父类的构造方法

- **实例代码**：

    ```java
    class Animal {
        void eat() {
            System.out.println("animal : eat");
        }
    }
    
    class Dog extends Animal {
        void eat() {
            System.out.println("dog : eat");
        }
    }
    void eatTest() {
        this.eat();   // this 调用自己的方法
        super.eat();  // super 调用父类方法
        }
    }
    
    public class Test {
        public static void main(String[] args) {
            Animal a = new Animal();
            a.eat();
            Dog d = new Dog();
            d.eatTest();
        }
    }
    ```

    输出结果：

    ```
    animal : eat
    dog : eat
    animal : eat
    ```

#### 构造器

子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。

如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。

构造器不能被继承，因此不能被重写，但可以被重载。

实例代码：

```java
public class SuperClass {
    private int n;

    SuperClass() {
        System.out.println("SuperClass()");
    }

    SuperClass(int n) {
        System.out.println("SuperClass(int n)");
        this.n = n;
    }
}

// SubClass 类继承
public class SubClass extends SuperClass {
    private int n;

    SubClass() { // 自动调用父类的无参数构造器
        System.out.println("SubClass");
    }

    public SubClass(int n) {
        super(300);  // 调用父类中带有参数的构造器
        System.out.println("SubClass(int n):" + n);
        this.n = n;
    }
}

// SubClass2 类继承
public class SubClass2 extends SuperClass {
    private int n;

    SubClass2() {
        super(300);  // 调用父类中带有参数的构造器
        System.out.println("SubClass2");
    }

    public SubClass2(int n) { // 自动调用父类的无参数构造器
        System.out.println("SubClass2(int n):" + n);
        this.n = n;
    }
}

public class TestSuperSub {
    public static void main(String args[]) {
        System.out.println("------SubClass 类继承------");
        SubClass sc1 = new SubClass();
        SubClass sc2 = new SubClass(100);
        System.out.println("------SubClass2 类继承------");
        SubClass2 sc3 = new SubClass2();
        SubClass2 sc4 = new SubClass2(200);
    }
}
```

输出结果：

```
------SubClass 类继承------
SuperClass()
SubClass
SuperClass(int n)
SubClass(int n):100
------SubClass2 类继承------
SuperClass(int n)
SubClass2
SuperClass()
SubClass2(int n):200
```

#### 抽象类和抽象方法

- **抽象类**

    抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

    由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

    在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

    **普通类和抽象类有哪些区别？**

    > 抽象类不能被实例化
    >
    > 抽象类可以有抽象方法，只允许声明，不允许实现
    >
    > 含有抽象方法的类必须申明为抽象类
    >
    > 抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类
    >
    > 抽象方法不能被声明为静态
    >
    > 抽象方法不能用private修饰
    >
    > 抽象方法不能用final修饰

- **抽象方法**

    **Abstract** 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

    抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

    ```java
    public abstract class Employee
    {
       private String name;
       private String address;
       private int number;
       
       public abstract double computePay();
    }
    ```

    声明抽象方法会造成以下两个结果：

    > 如果一个类包含抽象方法，那么该类必须是抽象类。
    >
    > 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

    继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。

    最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

**抽象类必须要有抽象方法吗？**

*不一定*，实例代码：

```java
public abstract class TestAbstractClass {
    public static void notAbstractMethod() {
        System.out.println("I am not a abstract method.");
    }
}
```

**抽象类总结规定**

- 抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#### 抽象类和接口的区别

- 抽象类可以有构造方法；接口中不能有构造方法。

- 抽象类中可以包含非抽象普通方法；接口中的所有方法必须都是抽象的，默认即为 **public abstract **类型。

- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。

- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。

- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。

  *JDK 1.8 以后，接口里可以有静态方法和方法体了*

  ```java
  public interface TestInterfaceStaticMethod {
      static String getA() {
          return "a";
      }
  }
  ```

- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

#### final static abstract 之间的关系

  - final、abstract不能共存（无论在类、方法、属性、局部变量上都不能共存）
  - static、abstract不能共存（无论在类、方法、属性、局部变量上都不能共存）
  - 可以出现 final static field（该类成员属性不能被修改）
  - 可以出现 final static method（该类成员方法不能被 override）

#### 构造函数与默认构造函数

构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。

构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。

如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -> 0，Integer -> null。

#### 类变量、成员变量与局部变量

Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。

```java
public class Variables {
    /**
     * 类变量
     */
    private static int a;

    /**
     * 成员变量
     */
    private int b;

    /**
     * 局部变量
     *
     * @param c
     */
    public void test(int c) {
        int d;
    }
}
```

上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。

#### 成员变量的隐藏

如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即这个成员变量在这个方法内暂时失效。

#### 成员变量和方法作用域

对于成员变量和方法的作用域，public，protected，private以及不写之间的区别：

`public` : 表明该成员变量或者方法是对所有类或者对象都是可见的,所有类或者对象都可以直接访问

`private` : 表明该成员变量或者方法是私有的,只有当前类对其具有访问权限，除此之外其他类或者对象都没有访问权限。子类也没有访问权限

`protected` : 表明成员变量或者方法对类自身，与同在一个包中的其他类可见，其他包下的类不可访问，除非是他的子类

`default` : 表明该成员变量或者方法只有自己和其位于同一个包的内可见，其他包内的类不能访问,即便是它的子类

#### 类方法和实例方法

- **类方法**

  > 加static修饰的是类方法（静态方法）
  >
  > 类方法只能对类变量进行操作
  >
  > 类方法只能调用该类的类方法，不能调用实例方法

- **实例方法**

  > 不加static关键字修饰的方法
  >
  > 实例方法既能对类变量操作也能对实例变量操作
  >
  > 实例方法可以调用该类的其他方法

#### Java 中的内部类

**内部类（ Inner Class ）**

定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。

**内部类的主要作用：**

> 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
>
> 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
>
> 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

**内部类可分为以下几种：**

- **成员内部类**

  内部类中最常见的就是成员内部类，也称为普通内部类。

  示例代码：

  ```java
  //外部类Outer
  public class Outer {
      private int a = 99;//外部类的私有属性
  
      //内部类Inner
      public class Inner {
          int b = 2;//内部类的成员属性
  
          public void test() {
              System.out.println("访问外部类中的a：" + a);
              System.out.println("访问内部类中的b：" + b);
          }
      }
  
      //测试成员内部类
      public static void main(String[] args) {
          Outer o = new Outer();//创建外部类对象，对象名为o
          Inner i = o.new Inner();//使用外部类对象创建内部类对象，对象名为i
          i.test();//调用内部类对象的test方法
      }
  }
  ```

  运行结果：

  ```
  访问外部类中的a：99
  访问内部类中的b：b
  ```

  **成员内部类的使用方法：**

  1. Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public、protected 、private 等

  2. Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a

  3. 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( )

  4. 编译上面的程序后，会发现产生了两个 .class 文件，即成员内部类的 .class 文件总是这样：外部类名$内部类名.class

    <img src="https://s2.ax1x.com/2020/02/02/1NSiod.png" />

  **友情提示：**

  1. 外部类不能直接使用内部类的成员和方法

  2. 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字

     示例代码：

     ```java
     //外部类Outer
     public class Outer {
         int b = 1;//外部类的成员属性b
     
         //内部类Inner
         public class Inner {
             int b = 2;//内部类的成员属性b
     
             public void test() {
                 System.out.println("访问外部类中的b：" + Outer.this.b);
                 System.out.println("访问内部类中的b：" + b);
             }
         }
     }
     ```

- **静态内部类（Static Nested Class）**

  静态内部类是 static 修饰的内部类，这种内部类的特点是：

  1. 静态内部类不能直接访问外部类的非静态成员，但可以通过 **new 外部类().成员** 的方式访问
  2. 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
  3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 **内部类 对象名= new 内部类();**

  示例代码：

  ```java
  //外部类
  public class SOuter {
      private int a = 99;//外部类的私有变量
      static int b = 1;//外部类的静态变量
  
      //静态内部类
      public static class SInner {
          int b = 2;//内部类的变量
  
          public void test() 
              System.out.println("访问外部类中的a：" + new SOuter().a);
              System.out.println("访问外部类中的b：" + SOuter.b);
              System.out.println("访问内部类中的b：" + b);
          }
      }
  
      public static void main(String[] args) {
          SInner sInner = new SInner();
          sInner.test();
      }
  }
  ```

- **方法内部类**

  方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。

  示例代码：

  ```java
  //外部类
  public class MOuter {
      //外部类中的方法
      public void show() {
          final int a = 25;//常量
          int b = 13;//变量
          //方法内部类
          class MInner {
              int c = 2;//内部类中的变量
  
              public void print() {
                  System.out.println("访问外部类的方法中的常量a：" + a);
                  System.out.println("访问外部类的方法中的变量b：" + b);
                  System.out.println("访问内部类中的变量c：" + c);
              }
          }
          MInner mInner = new MInner();//创建方法内部类的对象
          mInner.print();//调用内部类的方法
      }
  
      //测试方法内部类
      public static void main(String[] args) {
          MOuter mOuter = new MOuter();
          mOuter.show();
      }
  }
  ```

  **注意：**由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

- **匿名内部类（Anonymous Class）**

  :::tip
  匿名类：没有名称的类，其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺序，没有名称也就是其他地方就不能引用，不能实例化，只用一次，当然也就不能有构造器

  匿名类就是利用父类的构造函数和自身类体构造成一个类

  格式中的“父类”是子类需要继承或者实现外部的类或者接口

  匿名类可以继承父类的方法，也可以重写父类的方法

  匿名类可以访问外部类的成员变量和方法，匿名类的类体不可以声明称static成员变量和static方法

  匿名类由于是一个new的结果，所以其实可以赋值给一个父类对象。因此可以分为两种匿名类，成员匿名类和局部匿名类（作为函数参数）
  :::

### 平台无关性

#### Java如何实现的平台无关性的

- **什么是平台无关性**

  平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。

  也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。

- **平台无关性的好处**

  作为一门平台无关性语言，无论是在自身发展，还是对开发者的友好度上都是很突出的。

  因为其平台无关性，所以Java程序可以运行在各种各样的设备上，尤其是一些嵌入式设备，如打印机、扫描仪、传真机等。随着5G时代的来临，也会有更多的终端接入网络，相信平台无关性的Java也能做出一些贡献。

  对于Java开发者来说，Java减少了开发和部署到多个平台的成本和时间。真正的做到一次编译，到处运行。

- **平台无关性的实现**

  对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。

- **编译原理基础**

  在计算机世界中，计算机只认识0和1，所以，真正被计算机执行的其实是由0和1组成的二进制文件。

  但是，日常开发使用的C、C++、Java、Python等都属于高级语言，而非二进制语言。所以，想要让计算机认识我们写出来的Java代码，那就需要把他"翻译"成由0和1组成的二进制文件。这个过程就叫做编译。负责这一过程的处理的工具叫做编译器。

  在[深入分析Java的编译原理](https://www.hollischuang.com/archives/2322)中我们介绍过，在Java平台中，想要把Java文件，编译成二进制文件，需要经过两步编译，前端编译和后端编译：

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15539284762449.jpg" />

  前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的`javac`的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把`.java`代码转换成`.class`代码。

  这里提到的`.class`代码，其实就是Class文件。

  后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15539289530245.jpg" />

  所以，我们说的，Java的平台无关性实现主要作用于以上阶段。如下图所示：

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15539291533175.jpg" />

  我们从后往前介绍一下这三位主演：Java虚拟机、Class文件、Java语言规范

  **Java虚拟机**

  所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。

  对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。

  而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但是JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15539297082025.jpg" />

  上图是Oracle官网下载JDK的指引，不同的操作系统需要下载对应的Java虚拟机。

  有了Java虚拟机，想要执行a+b操作，A操作系统上面的虚拟机就会把指令翻译成10001000，B操作系统上面的虚拟机就会把指令翻译成11101110。

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15539303829914.jpg" />

  所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。

- **字节码**

  各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由字节码组成的Class文件进行交互。

  我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。

  因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。

- **Java语言规范**

  已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？

  其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。

  比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C/C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。

  举一个简单的例子，对于int类型，在Java中，int占4个字节，这是固定的。

  但是在C++中却不是固定的了。在16位计算机上，int类型的长度可能为两字节；在32位计算机上，可能为4字节；当64位计算机流行起来后，int类型的长度可能会达到8字节。（这里说的都是可能哦！）

  通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。

- **小结**

  > Java语言规范：通过规定Java语言中基本数据类型的取值范围和行为
  >
  > Class文件：所有Java文件要编译成统一的Class文件
  >
  > Java虚拟机：通过Java虚拟机将Class文件转成对应平台的二进制文件等

  Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异

- **语言无关性**

  其实，Java的无关性不仅仅体现在平台无关性上面，向外扩展一下，Java还具有语言无关性。

  前面我们提到过。JVM其实并不是和Java文件进行交互的，而是和Class文件，也就是说，其实JVM运行的时候，并不依赖于Java语言。

  时至今日，商业机构和开源机构已经在Java语言之外发展出一大批可以在JVM上运行的语言了，如Groovy、Scala、Jython等。之所以可以支持，就是因为这些语言也可以被编译成字节码（Class文件），而虚拟机并不关心字节码是有哪种语言编译而来的。详见[牛逼了，教你用九种语言在JVM上输出HelloWorld](https://www.hollischuang.com/archives/2938)

#### JVM还支持哪些语言

**Kotlin**

Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。Kotlin的设计初衷就是用来生产高性能要求的程序的，所以运行起来和Java也是不相上下。Kotlin可以从 JetBrains InteilliJ Idea IDE这个开发工具以插件形式使用。

**Hello World In Kotlin**

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

**Groovy**

Apache的Groovy是Java平台上设计的面向对象编程语言。它的语法风格与Java很像，Java程序员能够很快的熟练使用 Groovy，实际上，Groovy编译器是可以接受完全纯粹的Java语法格式的。

使用Groovy的一个重要特点就是使用类型推断，即能够让编译器能够在程序员没有明确说明的时候推断出变量的类型。Groovy可以使用其他Java语言编写的库。Groovy的语法与Java非常相似，大多数Java代码也匹配Groovy的语法规则，尽管可能语义不同。

**Hello World In Groovy**

```groovy
static void main(String[] args) {
    println('Hello, world!');
}
```

**Scala**

Scala是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。

Scala经常被我们描述为多模式的编程语言，因为它混合了来自很多编程语言的元素的特征。但无论如何它本质上还是一个纯粹的面向对象语言。它相比传统编 程语言最大的优势就是提供了很好并行编程基础框架措施了。Scala代码能很好的被优化成字节码，运行起来和原生Java一样快。

**Hello World In Scala**

```scala
object HelloWorld {
    def main(args: Array[String]) {
       System.out.println("Hello, world!");
    }
 }
```

**Jruby**

JRuby是用来桥接Java与Ruby的，它是使用比Groovy更加简短的语法来编写代码，能够让每行代码执行更多的任务。就和Ruby一样，JRuby不仅仅只提供了高级的语法格式。它同样提供了纯粹的面向对象的实现，闭包等等，而且JRuby跟Ruby自身相比多了很多基于Java类库 可以调用，虽然Ruby也有很多类库，但是在数量以及广泛性上是无法跟Java标准类库相比的。

**Hello World In Jruby**

```ruby
puts 'Hello, world!'
```

**Jython**

Jython，是一个用Java语言写的Python解释器。Jython能够用Python语言来高效生成动态编译的Java字节码。

**Hello World In Jython**

```py
print "Hello, world!"
```

**Fantom**

Fantom是一种通用的面向对象编程语言，由Brian和Andy Frank创建，运行在Java Runtime Environment，JavaScript和.NET Common Language Runtime上。其主要设计目标是提供标准库API，以抽象出代码是否最终将在JRE或CLR上运行的问题。

Fantom是与Groovy以及JRuby差不多的一样面向对 象的编程语言，但是悲剧的是Fantom无法使用Java类库，而是使用它自己扩展的类库。

**Hello World In Fantom**

```fantom
class Hello {
    static Void main() { echo("Hello, world!") }
}
```

**Clojure**

Clojure是Lisp编程语言在Java平台上的现代、函数式及动态方言。 与其他Lisp一样，Clojure视代码为数据且拥有一套Lisp宏系统。

虽然Clojure也能被直接编译成Java字节码，但是无法使用动态语言特性以及直 接调用Java类库。与其他的JVM脚本语言不一样，Clojure并不算是面向对象的。

**Hello World In Clojure**

```clojure
(defn -main [& args]
    (println "Hello, World!"))
```

**Rhino**

Rhino是一个完全以Java编写的JavaScript引擎，目前由Mozilla基金会所管理。

Rhino的特点是为JavaScript加了个壳，然后嵌入到Java中，这样能够让Java程序员直接使用。其中Rhino的JavaAdapters能够让JavaScript通过调用Java的类来实现特定的功能。

**Hello World In Rhino0**

```js
print('Hello, world!')
```

**Ceylon**

Ceylon是一种面向对象，强烈静态类型的编程语言，强调不变性，由Red Hat创建。 Ceylon程序在Java虚拟机上运行，可以编译为JavaScript。 语言设计侧重于源代码可读性，可预测性，可扩展性，模块性和元编程性。

**Hello World In Ceylon**

```ceylon
shared void run() {
    print("Hello, world!");
}
```

### 值传递

#### 值传递、引用传递

- **值传递与引用传递**

  上面提到了，当调用一个有参函数的时候，会把实际参数传递给形式参数。但是，在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。我们来看下程序语言中是如何定义和区分值传递和引用传递的。

  值传递（pass by value）：在调用函数时将实际参数`复制`一份传递到函数中，这样在函数中如果对`参数`进行修改，将不会影响到实际参数。
  
  引用传递（pass by reference）：在调用函数时将实际参数的地址`直接`传递到函数中，那么在函数中对`参数`所进行的修改，将影响到实际参数。

  值传递和引用传递之前的区别的重点：

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass.jpg" />

  形象的例子：

  你有一把钥匙，当你的朋友想要去你家的时候，如果你`直接`把你的钥匙给他了，这就是引用传递。这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。

  你有一把钥匙，当你的朋友想要去你家的时候，你`复刻`了一把新钥匙给他，自己的还在自己手里，这就是值传递。这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。

- **参考资料**

  [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)

  [关于值传递和引用传递](http://chenwenbo.github.io/2016/05/11/%E5%85%B3%E4%BA%8E%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/)

  [Is Java “ pass-by-reference” or “ pass-by-value” ?](https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value)

#### 为什么说Java中只有值传递

- **错误理解**

  :::danger
  错误理解一：值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递。
  
  错误理解二：Java是引用传递。
  
  错误理解三：传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。
  :::

- **实参与形参**

  参数在程序语言中分为形式参数和实际参数

  形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。
  
  实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。

  简单举个例子：

  ```java
  public static void main(String[] args) {
    ParamTest pt = new ParamTest();
    pt.sout("William");//实际参数为 Hollis
  }
  
  public void sout(String name) { //形式参数为 name
    System.out.println(name);
  }
  ```

  实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。

- **求值策略**

  当进行方法调用的时候，需要把实际参数传递给形式参数，那么传递的过程中到底传递的是什么东西呢？

  这其实是程序设计中**求值策略（Evaluation strategies）**的概念。

  在计算机科学中，求值策略是确定编程语言中表达式的求值的一组（通常确定性的）规则。求值策略定义何时和以何种顺序求值给函数的实际参数、什么时候把它们代换入函数、和代换以何种形式发生。

  求值策略分为两大基本类，基于如何处理给函数的实际参数，分为严格的和非严格的。

- **严格求值**

  在严格求值中，函数调用过程中，给函数的实际参数总是在应用这个函数之前求值。多数现存编程语言对函数都使用严格求值。

  在严格求值中有几个关键的求值策略是我们比较关心的，那就是**传值调用**（Call by value）、**传引用调用**（Call by reference）以及**传共享对象调用**（Call by sharing）。

  1. 传值调用（值传递）

    在传值调用中，实际参数先被求值，然后其值通过复制，被传递给被调函数的形式参数。因为形式参数拿到的只是一个"局部拷贝"，所以如果在被调函数中改变了形式参数的值，并不会改变实际参数的值

  2. 传引用调用（引用传递）

    在传引用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，改变对于调用者来说是可见的。

  3. 传共享对象调用（共享对象传递）

    传共享对象调用中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们也称之为"传共享对象"，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。

  其实传共享对象调用和传值调用的过程几乎是一样的，都是进行"求值"、"拷贝"、"传递"。

  但是，传共享对象调用和内传引用调用的结果又是一样的，都是在被调函数中如果改变参数的内容，那么这种改变也会对调用者有影响。

  那么，共享对象传递和值传递以及引用传递之间到底有什么关系呢？

  对于这个问题，应该关注过程，而不是结果，**因为传共享对象调用的过程和传值调用的过程是一样的，而且都有一步关键的操作，那就是"复制"，所以，通常我们认为传共享对象调用是传值调用的特例**

  传值调用和传引用调用两者的最主要区别就是直接传递的，还是传递的是一个副本。

- **Java的求值策略**

  很多人说Java中的基本数据类型是值传递的，这个基本没有什么可以讨论的，普遍都是这样认为的。

  但是，有很多人却误认为Java中的对象传递是引用传递。之所以会有这个误区，主要是因为Java中的变量和对象之间是有引用关系的。Java语言中是通过对象的引用来操纵对象的。所以，很多人会认为对象的传递是引用的传递。

  而且很多人还可以举出以下的代码示例：

  ```java
  public static void main(String[] args) {
    Test pt = new Test();
    User user = new User();
    hollis.setName("William");
    hollis.setGender("Male");
    pt.pass(hollis);
    System.out.println("print in main , user is " + user);
  }
  
  public void pass(User user) {
    user.setName("william");
    System.out.println("print in pass , user is " + user);
  }
  ```

  输出结果：

  ```
  print in pass , user is User{name='william', gender='Male'}
  print in main , user is User{name='william', gender='Male'}
  ```

  可以看到，对象类型在被传递到pass方法后，在方法内改变了其内容，最终调用方main方法中的对象也变了。

  所以，很多人说，这和引用传递的现象是一样的，就是在方法内改变参数的值，会影响到调用方。

  但是，其实这是走进了一个误区。

- **Java中的对象传递**

  前面说过，无论是值传递，还是引用传递，只不过是求值策略的一种，那求值策略还有很多，比如前面提到的共享对象传递的现象和引用传递也是一样的。那凭什么就说Java中的参数传递就一定是引用传递而不是共享对象传递呢？

  那么，Java中的对象传递，到底是哪种形式呢？其实，还真的就是共享对象传递。

  其实在 《The Java™ Tutorials》中，是有关于这部分内容的说明的。首先是关于基本类型描述如下：

  > Primitive arguments, such as an int or a double, are passed into methods by value. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost.

  **即，原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。**

  关于对象传递的描述如下：

  > Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.

  **也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值。**

  这一点官方文档已经很明确的指出了，Java就是值传递，只不过是把对象的引用当做值传递给方法。

  **其实Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调函数的形式参数。**只不过"传共享对象调用"这个词并不常用，所以Java社区的人通常说"Java是传值调用"，这么说也没错，因为传共享对象调用其实是传值调用的一个特例。

- **值传递和共享对象传递的现象冲突吗？**

  共享对象传递是值传递的一个特例，那么为什么他们的现象是完全不同的呢？

  难道值传递过程中，如果在被调方法中改变了值，也有可能会对调用者有影响吗？那到底什么时候会影响什么时候不会影响呢？

  其实是不冲突的，之所以会有这种疑惑，是因为大家对于到底什么是"改变值"有误解。

  我们先回到上面的例子中来，看一下调用过程中实际上发生了什么？

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass21.png" />

  在参数传递的过程中，实际参数的地址`0X1213456`被拷贝给了形参。这个过程其实就是值传递，只不过传递的值得内容是对象的引用。

  那为什么我们改了user中的属性的值，却对原来的user产生了影响呢？

  其实，这个过程就好像是：你复制了一把你家里的钥匙给到你的朋友，他拿到钥匙以后，并没有在这把钥匙上做任何改动，而是通过钥匙打开了你家里的房门，进到屋里，把你家的电视给砸了。

  这个过程，对你手里的钥匙来说，是没有影响的，但是你的钥匙对应的房子里面的内容却是被人改动了。

  也就是说，**Java对象的传递，是通过复制的方式把引用关系传递了，如果我们没有改引用关系，而是找到引用的地址，把里面的内容改了，是会对调用方有影响的，因为大家指向的是同一个共享对象。**

  那么，如果我们改动一下pass方法的内容：

  ```java
  public void pass(User user) {
    user = new User();
    user.setName("hollischuang");
    System.out.println("print in pass , user is " + user);
  }
  ```

  上面的代码中，我们在pass方法中，重新new了一个user对象，并改变了他的值，输出结果如下：

  ```
  print in pass , user is User{name='hollischuang', gender='Male'}
  print in main , user is User{name='Hollis', gender='Male'}
  ```

  再看一下整个过程中发生了什么：

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass1.png" />

  这个过程，就好像你复制了一把钥匙给到你的朋友，你的朋友拿到你给他的钥匙之后，找个锁匠把他修改了一下，他手里的那把钥匙变成了开他家锁的钥匙。这时候，他打开自己家，就算是把房子点了，对你手里的钥匙，和你家的房子来说都是没有任何影响的。

  **所以，Java中的对象传递，如果是修改引用，是不会对原来的对象有任何影响的，但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。**

- **总结**

  我们知道，编程语言中需要进行方法间的参数传递，这个传递的策略叫做求值策略。

  在程序设计中，求值策略有很多种，比较常见的就是值传递和引用传递。还有一种值传递的特例——共享对象传递。

  值传递和引用传递最大的区别是传递的过程中有没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。

  在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用。

  **我们可以总结说，Java中的求值策略是共享对象传递，这是完全正确的。**

  但是，为了让大家都能理解你说的，**我们说Java中只有值传递，只不过传递的内容是对象的引用。这也是没毛病的。**

  但是，绝对不能认为Java中有引用传递。

- **参考资料**

  [The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)

  [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)

  [Is Java “pass-by-reference” or “pass-by-value”?](https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value)

  [Passing by Value vs. by Reference Visual Explanation](https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/)

### 可变参数

可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但是这些参数的类型必须相同。

可变参数使用"..."表示若干个参数，最后一个参数必须是参数列表中的最后一个参数。

定义如下：

```java
public int add(int... numbers) {
    int sum = 0;
    for (int num : numbers) {
        sum += num;
    }
    return sum;
}
```

可以使用下面这几种方式进行可变参数的调用：

```java
add(); // 不传参数
add(1); // 传递一个参数
add(2,1); // 传递多个参数
add(new Integer[] {1, 3, 2}); // 传递数组
```

## Java 语言基础

### 标识符命名规则

- 由26个英文字母大小写，数字：0-9 符号：_ $ ￥ 组成
- 标识符应以字母、_ 、$ 开头
- 标识符不能是关键字

### 基础数据类型

#### 8种基本数据类型

Java中有8种基本数据类型分为三大类：

- **字符型：char**

- **布尔型：boolean**

- **数值型**

  整型：byte、short、int、long

  浮点型：float、double

:::tip
注意：String不是基本数据类型，是引用类型
:::

实际上，Java 中还存在另外一种基本类型 `void`，它也有对应的包装类 `java.lang.Void`，不过我们无法直接对它们进行操作。

#### 基本数据类型有什么好处

我们都知道在`Java`语言中，`new` 一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。

对于经常用到的类型，如`int`等，如果我们每次使用这种变量的时候都需要`new`一个`Java`对象的话，就会比较笨重。所以，和`C++`一样，Java提供了基本数据类型，这种数据的变量不需要使用`new`创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。

#### 整型的取值范围

Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。

先来个简答的科普，1字节=8位（bit）。java中的整型属于有符号数。

先来看计算中8bit可以表示的数字： 

最小值：10000000 （-128）(-2^7) 

最大值：01111111（127）(2^7-1) 

具体计算方式参考：[Java中，为什么byte类型的取值范围为-128~127? - CSDN博客](https://blog.csdn.net/qq_23418393/article/details/57421688)

| 类型  | 字节数  |                             范围                             |        默认值         |
| :---: | :-----: | :----------------------------------------------------------: | :-------------------: |
| byte  | 1个字节 |                    -128(-2^7)到127(2^7-1)                    |           0           |
| short | 2个字节 |               -32,768 (-2^15)到32,767 (2^15-1)               |           0           |
|  int  | 4个字节 |        -2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)        |           0           |
| long  | 8个字节 | -9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1) | 0L或0l，也可直接写为0 |

上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：

```java
int i = Integer.MAX_VALUE;
int j = Integer.MAX_VALUE;

int k = i + j;
System.out.println("i (" + i + ") + j (" + j + ") = k (" + k + ")");
```

输出结果：`i (2147483647) + j (2147483647) = k (-2)`

这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。

#### 什么是浮点型？

在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。

计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -> 010)。

1的二进制是01，1.0/2=0.5，那么，0.5的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如0.1，因此只能使用近似值的方式表达。

也就是说，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为10的科学计数法。

一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。

位（bit）是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。

#### 什么是单精度和双精度？

单精度浮点数在计算机存储器中占用4个字节（32bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。

比起单精度浮点数，双精度浮点数（double）使用`64`位（8字节）来存储一个浮点数。

#### 为什么不能用浮点型表示金额？

由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。

建议使用BigDecimal或者Long（单位为分）来表示金额。

####  什么是char类型？

char类型是一个采用`UTF-16`编码表示`Unicode`码点的代码单元，单一的`16`位`Unicode`字符，最小值是`\u0000(0)`，最大值是`\uffff(65535)`

```java
public static void main(String\u005B\ u00SD args)

\u005B 和 \u005D 是 [ 和 ] 的编码。
```

<center>特殊字符的转义序列</center>

| 转义序列 | 名称   | Unicode 值 |
| -------- | ------ | ---------- |
| \b       | 退格   | \u0008     |
| \t       | 制表   | \u0009     |
| \n       | 换行   | \u000a     |
| \r       | 回车   | \u000d     |
| \\''     | 双引号 | \u0022     |
| \\'      | 单引号 | \u0027     |
| \\\      | 反斜杠 | \u005c     |

### Java 运算符

#### 算术运算符

假设整数变量A的值为10，变量B的值为20：

| 操作符 | 描述                              | 例子           |
| :----- | :-------------------------------- | :------------- |
| +      | 加法 - 相加运算符两侧的值         | A + B 等于 30  |
| -      | 减法 - 左操作数减去右操作数       | A – B 等于 -10 |
| *      | 乘法 - 相乘操作符两侧的值         | A * B等于200   |
| /      | 除法 - 左操作数除以右操作数       | B / A等于2     |
| ％     | 取余 - 左操作数除以右操作数的余数 | B%A等于0       |

#### 自增与自减运算符

自增（++）自减（--）运算符是一种特殊的算术运算符

```java
public class selfAddMinus{
    public static void main(String[] args){
        int a = 3;
        int b = ++a;//自增运算
        int c = 3;
        int d = --c;//自减运算
        System.out.println("进行自增运算后的值等于"+b);
        System.out.println("进行自减运算后的值等于"+d);
    }
}
```

运行结果为：

```
进行自增运算后的值等于4
进行自减运算后的值等于2
```

前缀自增自减法(++a,--a)：先进行自增或者自减运算，再进行表达式运算。

后缀自增自减法(a++,a--)：先进行表达式运算，再进行自增或者自减运算。

```java
public class selfAddMinus{
    public static void main(String[] args){
        int a = 5;
        int b = 5;
        int x = 2*++a;
        int y = 2*b++;
        System.out.println("自增运算符前缀运算后a="+a+",x="+x);
        System.out.println("自增运算符后缀运算后b="+b+",y="+y);
    }
}
```

运行结果为：

```
自增运算符前缀运算后a=6，x=12
自增运算符后缀运算后b=6，y=10
```

#### 关系运算符

假设整数变量A的值为10，变量B的值为20：

| 运算符 | 描述                                                         | 例子           |
| :----- | :----------------------------------------------------------- | :------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真           | （A == B）为假 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真       | (A != B) 为真  |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真     | （A> B）为假   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真     | （A <B）为真   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真 | （A> = B）为假 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真 | （A <= B）为真 |

#### 位运算符

假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0           | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数           | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数           | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 | A>>>2得到15即0000 1111         |

#### 逻辑运算符

假设布尔变量A为真，变量B为假：

| 操作符 | 描述                                                         | 例子           |
| :----- | :----------------------------------------------------------- | :------------- |
| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | (A && B)为假   |
| \|\|   | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | (A \|\| B)为真 |
| !      | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | !(A && B)为真  |

#### 赋值运算符

| 操作符  | 描述                                                         | 例子                                     |
| :------ | :----------------------------------------------------------- | :--------------------------------------- |
| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
| * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
| << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
| >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
| ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
| ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
| \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

#### 运算符优先级

| 类别     | 操作符                                     | 关联性   |
| :------- | :----------------------------------------- | :------- |
| 后缀     | () [] . (点操作符)                         | 左到右   |
| 一元     | expr++ expr--                              | 从左到右 |
| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | > >= < <=                                  | 左到右   |
| 相等     | == !=                                      | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |

### Java中的关键字

#### transient

Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。这里的对象存储是指，Java的serialization提供的一种持久化对象实例的机制。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。使用情况是：当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。

简单点说，就是被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后，transient变量的值被设为初始值，如`int`型的是`0`，对象型的是`null`。

#### instanceof

instanceof是Java的一个二元操作符，类似于`==，>，<`等操作符。

instanceof是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回`boolean`的数据类型。

以下实例创建了`displayObjectClass()`方法来演示`Java instanceof`关键字用法：

```java
public static void displayObjectClass(Object o) {
  if (o instanceof Vector)
     System.out.println("对象是 java.util.Vector 类的实例");
  else if (o instanceof ArrayList)
     System.out.println("对象是 java.util.ArrayList 类的实例");
  else
    System.out.println("对象是 " + o.getClass() + " 类的实例");
}
```

#### volatile

- **volatile的用法**
- **volatile的原理**
- **volatile与可见性**
- **volatile与有效性**
- **volatile与原子性**
- **总结与思考**

#### synchronized

- **synchronized的用法**
- **synchronized的实现原理**
- **synchronized与原子性**
- **synchronized与可见性**
- **synchronized与有序性**
- **synchronized与锁优化**
- **总结与思考**

#### final

final是Java中的一个关键字，它所表示的是“这部分是无法修改的”。

使用final可以定义：变量、方法、类。

- **final变量**

  如果将变量设置为final，则不能更改final变量的值(它将是常量)。

  ```java
  class Test{
    final String name = "william";
  }
  ```

  一旦final变量被定义之后，是无法进行修改的。

- **final方法**

  如果任何方法声明为final，则不能覆盖它。

  ```java
  class Parent {
    final void name() {
        System.out.println("william");
    }
  }
  ```

  当我们定义以上类的子类的时候，无法覆盖其name方法，会编译失败。

- **final类**

  如果把任何一个类声明为final，则不能继承它。

  ```java
  final class Parent {
  
  }
  ```

  以上类不能被继承！

#### static

static表示“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块

- **静态变量**

  我们用static表示变量的级别，一个类中的静态变量，不属于类的对象或者实例。因为静态变量与所有的对象实例共享，因此他们不具线程安全性。

  通常，静态变量常用final关键来修饰，表示通用资源或可以被所有的对象所使用。如果静态变量未被私有化，可以用“类名.变量名”的方式来使用。

  ```java
  //static variable example
  private static int count;
  public static String str;
  ```

- **静态方法**

  与静态变量一样，静态方法是属于类而不是实例。

  一个静态方法只能使用静态变量和调用静态方法。通常静态方法通常用于想给其他的类使用而不需要创建实例。例如：Collections class(类集合)。

  Java的包装类和实用类包含许多静态方法。main()方法就是Java程序入口点，是静态方法。

  ```java
  //static method example
  public static void setCount(int count) {
    if(count >= 0)
    StaticExample.count = count;
  }
  
  //static util method
  public static int addInts(int i, int... js) {
    int sum = i;
    for (int x : js) sum += x;
    return sum;
  }
  ```

  从Java8以上版本开始也可以有接口类型的静态方法了。

- **静态代码块**

  Java的静态块是一组指令在类装载的时候在内存中由Java ClassLoader执行。

  静态块常用于初始化类的静态变量。大多时候还用于在类装载时候创建静态资源。

  Java不允许在静态块中使用非静态变量。一个类中可以有多个静态块，尽管这似乎没有什么用。静态块只在类装载入内存时，执行一次。

  ```java
  static{
      //can be used to initialize resources when class is loaded
      System.out.println("StaticExample static block");
      //can access only static variables and methods
      str = "Test";
      setCount(2);
  }
  ```

- **静态类**

  Java可以嵌套使用静态类，但是静态类不能用于嵌套的顶层。

  静态嵌套类的使用与其他顶层类一样，嵌套只是为了便于项目打包。

  StaticExample.java

  ```java
  public class StaticExample {
      //static block
      static {
          //can be used to initialize resources when class is loaded
          System.out.println("StaticExample static block");
          //can access only static variables and methods
          str = "Test" ;
          setCount(2);
      }
  
      //multiple static blocks in same class
      static {
          System.out.println("StaticExample static block2");
      }
  
      //static variable example
      private static int count; //kept private to control it's value through setter
      public static String str;
  
      public int getCount() {
          return count;
      }
  
      //static method example
      public static void setCount(int count) {
          if (count >= 0) {
              StaticExample.count = count;
          }
      }
  
      //static util method
      public static int addInts(int i, int... js) {
          int sum = i;
          for (int x : js) {
              sum += x;
          }
          return sum;
      }
  
      //static class example - used for packaging convenience only
      public static class MyStaticClass {
          public int count;
      }
  }
  ```

  接下来，在测试程序中使用这些静态变量、静态方法和静态类。

  TestStatic.java

  ```java
  public class TestStatic {
      public static void main(String[] args) {
          StaticExample.setCount(5);
  
          //non-private static variables can be accessed with class name
          StaticExample.str = "abc" ;
          StaticExample se = new StaticExample();
          System.out.println(se.getCount());
          //class and instance static variables are same
          System.out.println(StaticExample.str + "is same as+" + se.str);
          System.out.println(StaticExample.str == se.str);
  
          //static nested classes are like normal top-level classes
          StaticExample.MyStaticClass myStaticClass = new StaticExample.MyStaticClass();
          myStaticClass.count = 10;
  
          StaticExample.MyStaticClass myStaticClass1 = new StaticExample.MyStaticClass();
          myStaticClass1.count = 20;
  
          System.out.println(myStaticClass.count);
          System.out.println(myStaticClass1.count);
      }
  }
  ```

  执行结果如下：

  ```
  StaticExample static block
  StaticExample static block2
  5
  abc is same as abc
  true
  10
  20
  ```

  可见，静态块代码是最先被执行的，而且是只在类载入内存时执行。

#### const

const是Java预留关键字，用于后期扩展用，用法跟final相似，不常用

### String

#### 字符串的不可变性

- **定义一个字符串**

  ```java
  String s = "abcd";
  ```

  <img src="http://www.programcreek.com/wp-content/uploads/2009/02/String-Immutability-1.jpeg" />

  `s`中保存了string对象的引用，下面的箭头可以理解为“存储他的引用”

- **使用变量来赋值变量**

  ```java
  String s2 = s;
  ```

  <img src="http://www.programcreek.com/wp-content/uploads/2009/02/String-Immutability-2.jpeg" />

  s2保存了相同的引用值，因为他们代表同一个对象

- **字符串拼接**

  ```java
  s = s.concat("ef");
  ```

  <img src="http://www.programcreek.com/wp-content/uploads/2009/02/string-immutability-650x279.jpeg" />

  `s`中保存的是一个重新创建出来的string对象的引用

- **总结**

  一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。

  如果你需要一个可修改的字符串，应该使用StringBuffer 或者 StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。

#### JDK 6和JDK 7中substring的原理及区别

`substring(int beginIndex, int endIndex)`方法在不同版本的JDK中的实现是不同的。了解他们的区别可以帮助你更好的使用他。为简单起见，后文中用`substring()`代表`substring(int beginIndex, int endIndex)`方法。

- **subString()的作用**

  `substring(int beginIndex, int endIndex)`方法截取字符串并返回其`[beginIndex,endIndex-1]`范围内的内容。

  ```java
  String x = "abcdef";
  x = x.substring(1,3);
  System.out.println(x);
  ```

  输出内容：

  ```java
  bc
  ```

- **调用subString()时发生了什么？**

  因为x是不可变的，当使用`x.substring(1,3)`对x赋值的时候，它会指向一个全新的字符串：

  <img src="http://www.programcreek.com/wp-content/uploads/2013/09/string-immutability1-650x303.jpeg" />

  然而，这个图不是完全正确的表示堆中发生的事情。因为在jdk6 和 jdk7中调用substring时发生的事情并不一样。

- **JDK 6中的subString()**

  String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：`char value[]`， `int offset`，`int count`。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。

  当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。

  <img src="http://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg" />

  Java源码中的关键代码：

  ```java
  //JDK 6
  String(int offset, int count, char value[]) {
      this.value = value;
      this.offset = offset;
      this.count = count;
  }
  
  public String substring(int beginIndex, int endIndex) {
      //check boundary
      return new String(offset + beginIndex, endIndex - beginIndex, value);
  }
  ```

- **JDK 6中的subString()导致的问题**

  如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。

  ```java
  x = x.substring(x, y) + ""
  ```

  > 内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

- **JDK 7中的subString()**

  在JDK 7 中，substring方法会在堆内存中创建一个新的数组

  <img src="http://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg" />

  Java源码中关于这部分的主要代码如下：

  ```java
  //JDK 7
  public String(char value[], int offset, int count) {
      //check boundary
      this.value = Arrays.copyOfRange(value, offset, offset + count);
  }
  
  public String substring(int beginIndex, int endIndex) {
      //check boundary
      int subLen = endIndex - beginIndex;
      return new String(value, beginIndex, subLen);
  }
  ```

  以上是JDK 7中的subString方法，其使用`new String`创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。

  所以，如果你的生产环境中使用的JDK版本小于1.7，当你使用String的subString方法时一定要注意，避免内存泄露。

#### replaceFirst、replaceAll、replace区别

replace、replaceAll和replaceFirst是Java中常用的替换字符的方法,它们的方法定义是：

replace(CharSequence target, CharSequence replacement) ，用replacement替换所有的target，两个参数都是字符串。

replaceAll(String regex, String replacement) ，用replacement替换所有的regex匹配项，regex很明显是个正则表达式，replacement是字符串。

replaceFirst(String regex, String replacement) ，基本和replaceAll相同，区别是只替换第一个匹配项。

可以看到，其中replaceAll以及replaceFirst是和正则表达式有关的，而replace和正则表达式无关。

replaceAll和replaceFirst的区别主要是替换的内容不同，replaceAll是替换所有匹配的字符，而replaceFirst()仅替换第一次出现的字符

**用法例子**

1. replaceAll() 替换符合正则的所有文字

   ```java
   //文字替换（全部） 
   Pattern pattern = Pattern.compile("正则表达式"); 
   Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World"); 
   //替换第一个符合正则的数据 
   System.out.println(matcher.replaceAll("Java")); 
   ```

2. replaceFirst() 替换第一个符合正则的数据

   ```java
   //文字替换（首次出现字符） 
   Pattern pattern = Pattern.compile("正则表达式"); 
   Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World"); 
   //替换第一个符合正则的数据 
   System.out.println(matcher.replaceFirst("Java")); 
   ```

3. replaceAll()替换所有html标签

   ```java
   //去除html标记 
   Pattern pattern = Pattern.compile("<.+?>", Pattern.DOTALL); 
   Matcher matcher = pattern.matcher("<a href=\"index.html\">主页</a>"); 
   String string = matcher.replaceAll(""); 
   System.out.println(string); 
   ```

4. replaceAll() 替换指定文字

   ```java
   //替换指定{}中文字 
   String str = "Java目前的发展史是由{0}年-{1}年";
   String[][] object = {
    new String[] {
        "\\{0\\}",
        "1995"
    },
    new String[] {
        "\\{1\\}",
        "2007"
    }
   };
   System.out.println(replace(str, object));
   public static String replace(final String sourceString, Object[] object) {
    String temp = sourceString;
    for (int i = 0; i < object.length; i++) {
        String[] result = (String[]) object[i];
        Pattern pattern = Pattern.compile(result[0]);
        Matcher matcher = pattern.matcher(temp);
        temp = matcher.replaceAll(result[1]);
    }
    return temp;
   }
   ```

5. replace()替换字符串

   ```java
   System.out.println("abac".replace("a", "\\a")); //\ab\ac
   ```

#### String对“+”的重载

1. String s = "a" + "b"，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = "ab"
2. 对于能够进行优化的(String s = "a" + 变量 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())

#### 字符串拼接的几种方式和区别

基于jdk1.8.0_181

- **字符串拼接**

  **String是Java中一个不可变的类**，所以他一旦被实例化就无法被修改

  > 不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，比如可以缓存hashcode、使用更加便利以及更加安全。

  **字符串不变性与字符串拼接**

  其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。下面一段字符串拼接代码：

  ```java
  String s = "abcd";
  s = s.concat("ef");
  ```

  其实最后得到的s已经是一个新的字符串了。如下图：

  <img src="http://www.programcreek.com/wp-content/uploads/2009/02/string-immutability-650x279.jpeg" />

  `s`中保存的是一个重新创建出来的String对象的引用

  常见的字符串拼接方式：

  **使用`+`拼接字符串**

  在Java中，拼接字符串最简单的方式就是直接使用符号`+`来拼接。如：

  ```java
  String wechat = "Hollis";
  String introduce = "每日更新Java相关技术文章";
  String hollis = wechat + "," + introduce;
  ```

  这里要特别说明一点，有人把Java中使用`+`拼接字符串的功能理解为**运算符重载**。其实并不是，**Java是不支持运算符重载的**。这其实只是Java提供的一个**语法糖**。后面再详细介绍。

  > 运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。
  >
  > 语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。

  **concat**

  除了使用`+`拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：

  ```java
  String wechat = "Hollis";
  String introduce = "每日更新Java相关技术文章";
  String hollis = wechat.concat(",").concat(introduce);
  ```

  **StringBuffer**

  关于字符串，Java中除了定义了一个可以用来定义**字符串常量**的`String`类以外，还提供了可以用来定义**字符串变量**的`StringBuffer`类，它的对象是可以扩充和修改的。

  使用`StringBuffer`可以方便的对字符串进行拼接。如：

  ```java
  StringBuffer wechat = new StringBuffer("Hollis");
  String introduce = "每日更新Java相关技术文章";
  StringBuffer hollis = wechat.append(",").append(introduce);
  ```

  **StringBuilder**

  除了`StringBuffer`以外，还有一个类`StringBuilder`也可以使用，其用法和`StringBuffer`类似。如：

  ```java
  StringBuilder wechat = new StringBuilder("Hollis");
  String introduce = "每日更新Java相关技术文章";
  StringBuilder hollis = wechat.append(",").append(introduce);
  ```

  **StringUtils.join**

  除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如`apache.commons中`提供的`StringUtils`类，其中的`join`方法可以拼接字符串，如：

  ```java
  String wechat = "Hollis";
  String introduce = "每日更新Java相关技术文章";
  System.out.println(StringUtils.join(wechat, ",", introduce));
  ```

  这里简单说一下，StringUtils中提供的join方法，最主要的功能是：将数组或集合以某拼接符拼接到一起形成新的字符串，如：

  ```java
  String[] list = {"Hollis","每日更新Java相关技术文章"};
  String result = StringUtils.join(list, ",");
  System.out.println(result);
  //结果：Hollis,每日更新Java相关技术文章
  ```

  并且，Java8中的String类中也提供了一个静态的join方法，用法和StringUtils.join类似。

  以上就是比较常用的五种在Java种拼接字符串的方式，那么到底哪种更好用呢？为什么阿里巴巴Java开发手册中不建议在循环体中使用`+`进行字符串拼接呢？

  <img src="https://www.hollischuang.com/wp-content/uploads/2019/01/15472850170230.jpg" />

  
- **使用`+`拼接字符串的实现原理**

  使用`+`拼接字符串，其实只是Java提供的一个语法糖

  代码：

  ```java
  String wechat = "Hollis";
  String introduce = "每日更新Java相关技术文章";
  String hollis = wechat + "," + introduce;
  ```

  反编译工具为jad，反编译后的内容如下：

  ```java
  String wechat = "Hollis";
  String introduce = "\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0";//每日更新Java相关技术文章
  String hollis = (new StringBuilder()).append(wechat).append(",").append(introduce).toString();
  ```

  原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。

  那么也就是说，Java中的`+`对字符串的拼接，其实现原理是使用`StringBuilder.append`。

- **concat是如何实现的**

  concat方法的源代码：

  ```java
  public String concat(String str) {
      int otherLen = str.length();
      if (otherLen == 0) {
          return this;
      }
      int len = value.length;
      char buf[] = Arrays.copyOf(value, len + otherLen);
      str.getChars(buf, len);
      return new String(buf, true);
  }
  ```

  这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。

  通过源码也可以看到，经过concat方法，其实是new了一个新的String，这也就呼应到前面说的字符串的不变性问题上了。

- **StringBuffer和StringBuilder**

  和`String`类类似，`StringBuilder`类也封装了一个字符数组，定义如下：

  ```java
  char[] value;
  ```

  与`String`不同的是，它并不是`final`的，所以他是可以修改的。另外，与`String`不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：

  ```java
  int count;
  ```

  其append源码如下：

  ```java
  public StringBuilder append(String str) {
      super.append(str);
      return this;
  }
  ```

  该类继承了`AbstractStringBuilder`类，看下其`append`方法：

  ```java
  public AbstractStringBuilder append(String str) {
      if (str == null)
          return appendNull();
      int len = str.length();
      ensureCapacityInternal(count + len);
      str.getChars(0, len, value, count);
      count += len;
      return this;
  }
  ```

  append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。

  `StringBuffer`和`StringBuilder`类似，最大的区别就是`StringBuffer`是线程安全的，看一下`StringBuffer`的`append`方法。

  ```java
  public synchronized StringBuffer append(String str) {
      toStringCache = null;
      super.append(str);
      return this;
  }
  ```

  该方法使用`synchronized`进行声明，说明是一个线程安全的方法。而`StringBuilder`则不是线程安全的。

- **StringUtils.join是如何实现的**

  通过查看`StringUtils.join`的源代码，可以发现，其实它也是通过`StringBuilder`来实现的。

  ```java
  public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {
      if (array == null) {
          return null;
      }
      if (separator == null) {
          separator = EMPTY;
      }
  
      // endIndex - startIndex > 0: Len = NofStrings * (len(firstString) + len(separator))
      // (Assuming that all Strings are roughly equally long)
      final int noOfItems = endIndex - startIndex;
      if (noOfItems <= 0) {
          return EMPTY;
      }
  
      final StringBuilder buf = new StringBuilder(noOfItems * 16);
  
      for (int i = startIndex; i < endIndex; i++) {
          if (i > startIndex) {
              buf.append(separator);
          }
          if (array[i] != null) {
              buf.append(array[i]);
          }
      }
      return buf.toString();
  }
  ```

- **效率比较**

  ```java
  long t1 = System.currentTimeMillis();
  //这里是初始字符串定义
  for (int i = 0; i < 50000; i++) {
      //这里是字符串拼接代码
  }
  long t2 = System.currentTimeMillis();
  System.out.println("cost:" + (t2 - t1));
  ```

  使用形如以上形式的代码，分别测试下五种字符串拼接代码的运行时间。得到结果如下：

  ```java
  + cost:5119
  StringBuilder cost:3
  StringBuffer cost:4
  concat cost:3623
  StringUtils.join cost:25726
  ```

  从结果可以看出，用时从短到长的对比是：

  `StringBuilder`<`StringBuffer`<`concat`<`+`<`StringUtils.join`

  `StringBuffer`在`StringBuilder`的基础上，做了同步处理，所以在耗时上会相对多一些

  StringUtils.join也是使用了StringBuilder，并且其中还是有很多其他操作，所以耗时较长，这个也容易理解。其实StringUtils.join更擅长处理字符串数组或者列表的拼接。

  使用`+`拼接字符串的实现原理也是使用的`StringBuilder`，那为什么结果相差这么多，高达1000多倍呢？

  再把以下代码反编译下：

  ```java
  long t1 = System.currentTimeMillis();
  String str = "hollis";
  for (int i = 0; i < 50000; i++) {
      String s = String.valueOf(i);
      str += s;
  }
  long t2 = System.currentTimeMillis();
  System.out.println("+ cost:" + (t2 - t1));
  ```

  反编译后代码如下：

  ```java
  long t1 = System.currentTimeMillis();
  String str = "hollis";
  for(int i = 0; i < 50000; i++)
  {
      String s = String.valueOf(i);
      str = (new StringBuilder()).append(str).append(s).toString();
  }
  
  long t2 = System.currentTimeMillis();
  System.out.println((new StringBuilder()).append("+ cost:").append(t2 - t1).toString());
  ```

  可以看到，反编译后的代码，在`for`循环中，每次都是`new`了一个`StringBuilder`，然后再把`String`转成`StringBuilder`，再进行`append`。

  而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。

  所以，阿里巴巴Java开发手册建议：循环体内，字符串的连接方式，使用 `StringBuilder` 的 `append` 方法进行扩展。而不要使用`+`。

- **总结**

  虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。

  常用的字符串拼接方式有五种，分别是使用`+`、使用`concat`、使用`StringBuilder`、使用`StringBuffer`以及使用`StringUtils.join`。

  由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。

  因此，经过对比，直接使用`StringBuilder`的方式是效率最高的。因为`StringBuilder`天生就是设计来定义可变字符串和字符串的变化操作的。

  但是，还要强调的是：

  1、如果不是在循环体中进行字符串拼接的话，直接使用`+`就好了。

  2、如果在并发场景中进行字符串拼接的话，要使用`StringBuffer`来代替`StringBuilder`。

#### 检测字符串是否相等

可以使用 **equals** 方法检测两个字符串是否相等。对于表达式：s.equals(t)

如果字符串 s 与字符串 t 相等， 则返回 true ; 否则，返回 false。需要注意，s 与 t 可以是字符串变量， 也可以是字符串字面量。

例如， 下列表达式是合法的：

```java
"Hello".equals(greeting)  
```

要想检测两个字符串是否相等，而不区分大小写，可以使用 **equalsIgnoreCase** 方法：

```java
"Hello".equalsIgnoreCase("hel1o") 
```

*注意：一定不要使用 == 运算符检测两个字符串是否相等！这个运算符只能够确定两个字串是否放置在同一个位置上。*

如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。

  - **==**

    > 如果作用于基本数据类型的变量，则直接比较其存储的 “值” 是否相等
    >
    > 如果作用于引用类型的变量，则比较的是所指向的对象的地址

- **equals**

  > equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址，诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容

#### 空串与NULL串

空串 **""** 是长度为 0 的字符串。

检查一个字符串是否为空：

```java
if (str.lengthQ = 0)
或
if (str.equals(""))
```

空串是一个 Java 对象，有自己的串长度（0）和内容（空）。不过，String 变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联。

要检查一个字符串是否为 null，要使用以下条件：

```java
if (str == null)
```

检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：

```java
if (str != null && str.length() != 0)
```

首先要检查 str 不为 null。

#### 码点与代码单元

length 方法将返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。

```java
String greeting = "Hello";
int n = greeting.length(); // is 5.
```

要想得到实际的长度，即码点数量，可以调用：

```java
int cpCount = greeting.codePointCount(0, greeting.length());
```

调用 s.charAt(n) 将返回位置 n 的代码单元，n 介于 0 ~ s.length()-1 之间。例如：

```java
char first = greeting.charAt(0); // first is 'H'
char last = greeting.charAt(4); // last is ’o’
```

要想得到第 i 个码点，应该使用下列语句：

```java
int index = greeting.offsetByCodePoints(0,i);
int cp = greeting.codePointAt(index);  
```

如果想要遍历一个字符串，并且依次査看每一个码点，可以使用下列语句：

```java
int cp = sentence.codePointAt(i);
if (Character.isSupplementaryCodePoint(cp)) i += 2;
else i++;
```

可以使用下列语句实现回退操作：

```java
i++;
if (Character.isSurrogate(sentence.charAt(i))) i--;
int cp = sentence.codePointAt(i);  
```

更容易的办法是使用 codePoints 方法，它会生成一个 int 值的“ 流”，每个 int 值对应一个码点。可以将它转换为一个数组，再完成遍历。

```java
int[] codePoints = str.codePoints().toArray();
```

反之，要把一个码点数组转换为一个字符串，可以使用构造函数：

```java
String str = new String(codePoints, 0, codePoints.length);
```

#### String.valueOf和Integer.toString的区别

有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？

```java
int i = 5;
String i1 = "" + i;
String i2 = String.valueOf(i);
String i3 = Integer.toString(i);
```

第三行和第四行没有任何区别，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。

第二行代码其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。

#### switch 对 String 的支持

Java 7中，switch的参数可以是String类型了，到目前为止switch支持这样几种数据类型：`byte` `short` `int` `char` `String` 。但是，作为一个程序员我们不仅要知道他有多么好用，还要知道它是如何实现的，switch对整型的支持是怎么实现的呢？对字符型是怎么实现的呢？String类型呢？有一点Java开发经验的人这个时候都会猜测switch对String的支持是使用equals()方法和hashcode()方法。

- **switch对整型支持的实现**

  下面是一段很简单的Java代码，定义一个int型变量a，然后使用switch语句进行判断。执行这段代码输出内容为5

  ```java
  public class switchDemoInt {
      public static void main(String[] args) {
          int a = 5;
          switch (a) {
          case 1:
              System.out.println(1);
              break;
          case 5:
              System.out.println(5);
              break;
          default:
              break;
          }
      }
  }
  //output 5
  ```

  反编译后的代码如下：

  ```java
  public class switchDemoInt
  {
      public switchDemoInt()
      {
      }
      public static void main(String args[])
      {
          int a = 5;
          switch(a)
          {
          case 1: // '\001'
              System.out.println(1);
              break;
  
          case 5: // '\005'
              System.out.println(5);
              break;
          }
      }
  }
  ```

  反编译后的代码和之前的代码比较除了多了两行注释以外没有任何区别，那么就知道，**switch对int的判断是直接比较整数的值**。

- **switch对字符型支持的实现**

  ```java
  public class switchDemoInt {
      public static void main(String[] args) {
          char a = 'b';
          switch (a) {
          case 'a':
              System.out.println('a');
              break;
          case 'b':
              System.out.println('b');
              break;
          default:
              break;
          }
      }
  }
  ```

  编译后的代码如下：

  ```java
  public class switchDemoChar
  {
      public switchDemoChar()
      {
      }
      public static void main(String args[])
      {
          char a = 'b';
          switch(a)
          {
          case 97: // 'a'
              System.out.println('a');
              break;
          case 98: // 'b'
              System.out.println('b');
              break;
          }
    }
  }
  ```

  通过以上的代码作比较发现：对char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量

- **switch对字符串支持的实现**

  ```java
  public class switchDemoString {
      public static void main(String[] args) {
          String str = "world";
          switch (str) {
          case "hello":
              System.out.println("hello");
              break;
          case "world":
              System.out.println("world");
              break;
          default:
              break;
          }
      }
  }
  ```

  对代码进行反编译：

  ```java
  public class switchDemoString
  {
      public switchDemoString()
      {
      }
      public static void main(String args[])
      {
          String str = "world";
          String s;
          switch((s = str).hashCode())
          {
          default:
              break;
          case 99162322:
              if(s.equals("hello"))
                  System.out.println("hello");
              break;
          case 113318802:
              if(s.equals("world"))
                  System.out.println("world");
              break;
          }
      }
  }
  ```

  看到这个代码，你知道原来字符串的switch是通过`equals()`和`hashCode()`方法来实现的。**记住，switch中只能使用整型**，比如`byte`，`short`，`char`(ascii码是整型)以及`int`。还好`hashCode()`方法返回的是`int`，而不是`long`。通过这个很容易记住`hashCode`返回的是`int`这个事实。仔细看下可以发现，进行`switch`的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个`equals`方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把`hashCode()`方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个`switch`语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里`hashCode()`方法的调用开销其实不会很大。

  **其实switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后在使用switch的。**

#### 字符串池

String作为一个Java类，可以通过以下两种方式创建一个字符串：

```java
String str = "Hollis";

String str = new String("Hollis")；
```

而第一种是比较常用的做法，这种形式叫做"字面量"。

在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池。

当代码中出现双引号形式（字面量）创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。

这种机制，就是字符串驻留或池化。

**字符串常量池的位置**

在JDK 7以前的版本中，字符串常量池是放在永久代中的。

因为按照计划，JDK会在后续的版本中通过元空间来代替永久代，所以首先在JDK 7中，将字符串常量池先从永久代中移出，暂时放到了堆内存中。

在JDK 8中，彻底移除了永久代，使用元空间替代了永久代，于是字符串常量池再次从堆内存移动到元空间中，和堆相互独立。

#### Class常量池

在Java中，常量池的概念想必很多人都听说过。这也是面试中比较常考的题目之一。在Java有关的面试题中，一般习惯通过String的有关问题来考察面试者对于常量池的知识的理解，几道简单的String面试题难倒了无数的开发者。所以说，常量池是Java体系中一个非常重要的概念。

谈到常量池，在Java体系中，共用三种常量池。分别是**字符串常量池**、**Class常量池**和**运行时常量池**。

- **什么是Class文件**

  Java语言中负责编译出字节码的编译器是一个命令是`javac`。

  > javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。

  以下简单的`HelloWorld.java`代码：

  ```java
  public class HelloWorld {
      public static void main(String[] args) {
          String s = "Hollis";
      }
  }
  ```

  通过javac命令生成class文件：

  ```
  javac HelloWorld.java
  ```

  生成`HelloWorld.class`文件:

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/10/15401179593014.jpg" />

  > 如何使用16进制打开class文件：使用 `vim test.class` ，然后在交互模式下，输入`:%!xxd` 即可。

  上面的文件就是Class文件，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。

  > `HelloWorld.class`文件中的前八个字母是`cafe babe`，这就是Class文件的魔数（[Java中的”魔数”](http://www.hollischuang.com/archives/491)）

  在Class文件的4个字节的魔数后面的分别是4个字节的Class文件的版本号（第5、6个字节是次版本号，第7、8个字节是主版本号，我生成的Class文件的版本号是52，这是Java 8对应的版本。也就是说，这个版本的字节码，在JDK 1.8以下的版本中无法运行）在版本号后面的，就是Class常量池入口了。

- **Class常量池**

  Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

  由于不同的Class文件中包含的常量的个数是不固定的，所以在Class文件的常量池入口处会设置两个字节的常量池容量计数器，记录了常量池中常量的个数。

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/10/15401192359009.jpg" />

  当然，还有一种比较简单的查看Class文件中常量池的方法，那就是通过`javap`命令。对于以上的`HelloWorld.class`，可以通过

  ```
  javap -v  HelloWorld.class
  ```

  查看常量池内容如下:

  <img src="http://www.hollischuang.com/wp-content/uploads/2018/10/15401195127619.jpg" />

  > 从上图中可以看到，反编译后的class文件常量池中共有16个常量。而Class文件中常量计数器的数值是0011，将该16进制数字转换成10进制的结果是17。
  >
  > 原因是与Java的语言习惯不同，常量池计数器是从0开始而不是从1开始的，常量池的个数是10进制的17，这就代表了其中有16个常量，索引值范围为1-16。

- **常量池中有什么**

  常量池中主要存放两大类常量：字面量（literal）和符号引用（symbolic references）。

- **字面量**

  > 在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。

  说简单点，字面量就是指由字母、数字等构成的字符串或者数值。

  字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。在这个例子中123就是字面量。

  ```java
  int a = 123;
  String s = "hollis";
  ```

  上面的代码事例中，123和hollis都是字面量。

- 符号引用

  符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符

  这也就可以印证前面的常量池中还包含一些`com/hollis/HelloWorld`、`main`、`([Ljava/lang/String;)V`等常量的原因了。

- **Class常量池有什么用**

  首先，可以明确的是，Class常量池是Class文件中的资源仓库，其中保存了各种常量。而这些常量都是开发者定义出来，需要在程序的运行期使用的。

  在《深入理解Java虚拟机》中有这样的表述：

  Java代码在进行`Javac`编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在虚拟机类加载过程时再进行详细讲解。

  前面这段话，看起来很绕，不是很容易理解。其实他的意思就是： Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。

- 参考资料

  《深入理解java虚拟机》 [《Java虚拟机原理图解》 1.2.2、Class文件中的常量池详解（上）](https://blog.csdn.net/luanlouis/article/details/39960815)

#### 运行时常量池

运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池（ Constant_Pool）的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表（ SymbolTable）的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。

每一个运行时常量池都分配在 Java 虚拟机的`方法区`之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。

以上，是Java虚拟机规范中关于运行时常量池的定义。

- **运运行时常量池在JDK各个版本中的实现**

  根据Java虚拟机规范约定：每一个运行时常量池都在Java虚拟机的`方法区`中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

  在不同版本的JDK中，运行时常量池所处的位置也不一样。以HotSpot为例：

  在JDK 1.7之前，方法区位于堆内存的永久代中，运行时常量池作为方法区的一部分，也处于永久代中。

  因为使用永久代实现方法区可能导致内存泄露问题，所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中，将原本位于永久代中的运行时常量池移动到堆内存中。（永久代在JDK 1.7并没有完全移除，只是原来方法区中的运行时常量池、类的静态变量等移动到了堆内存中。）

  在JDK 1.8中，彻底移除了永久代，方法区通过元空间的方式实现。随之，运行时常量池也在元空间中实现。

- **运行时常量池中常量的来源**

  运行时常量池中包含了若干种不同的常量：

  编译期可知的字面量和符号引用（来自Class常量池） 运行期解析后可获得的常量（如String的intern方法）

  所以，运行时常量池中的内容包含：Class常量池中的常量、字符串常量池中的内容

- **运行时常量池、Class常量池、字符串常量池的区别与联系**

  虚拟机启动过程中，会将各个Class文件中的常量池载入到运行时常量池中。

  所以， Class常量池只是一个媒介场所。在JVM真的运行时，需要把常量池中的常量加载到内存中，进入到运行时常量池。

  字符串常量池可以理解为运行时常量池分出来的部分。加载时，对于class的静态常量池，字符串会被装到字符串常量池中。

#### intern

当代码中出现双引号形式（字面量）创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。

除了以上方式之外，还有一种可以在运行期将字符串内容放置到字符串常量池的办法，那就是使用intern

intern的功能很简单：

在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用。

#### String有没有长度限制？

- **String的长度限制**

  String类中有很多重载的构造函数，其中有几个是支持用户传入length来执行长度的：

  ```java
  public String(byte bytes[], int offset, int length) 
  ```

  可以看到，这里面的参数length是使用int类型定义的，那么也就是说，String定义的时候，最大支持的长度就是int的最大范围值。

  根据Integer类的定义，`java.lang.Integer#MAX_VALUE`的最大值是2^31 - 1

  那么，是不是就可以认为String能支持的最大长度就是这个值了呢？

  其实并不是，这个值只是在运行期，构造String的时候可以支持的一个最大长度，而实际上，在编译期，定义字符串的时候也是有长度限制的。

  如以下代码：

  ```java
  String s = "11111...1111";//其中有10万个字符"1"
  ```

  当使用如上形式定义一个字符串的时候，当执行javac编译时，是会抛出异常的，提示如下：

  ```
  错误: 常量字符串过长
  ```

  那么，明明String的构造函数指定的长度是可以支持2147483647(2^31 - 1)的，为什么像以上形式定义的时候无法编译呢？

  其实，形如`String s = "xxx";`定义String的时候，xxx被称之为字面量，这种字面量在编译之后会以常量的形式进入到Class常量池。

  那么问题就来了，因为要进入常量池，就要遵守常量池的有关规定。

- **常量池限制**

  javac是将Java文件编译成class文件的一个命令，那么在Class文件生成过程中，就需要遵守一定的格式。

  根据《Java虚拟机规范》中第4.4章节常量池的定义，CONSTANT_String_info 用于表示 java.lang.String 类型的常量对象，格式如下：

  ```j
  CONSTANT_String_info {
      u1 tag;
      u2 string_index;
  }
  ```

  其中，string_index 项的值必须是对常量池的有效索引， 常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示一组 Unicode 码点序列，这组 Unicode 码点序列最终会被初始化为一个 String 对象。

  CONSTANT_Utf8_info 结构用于表示字符串常量的值：

  ```
  CONSTANT_Utf8_info {
      u1 tag;
      u2 length;
      u1 bytes[length];
  }
  ```

  其中，length则指明了 bytes[]数组的长度，其类型为u2，

  通过翻阅《规范》，可以获悉。u2表示两个字节的无符号数，那么1个字节有8位，2个字节就有16位。

  16位无符号数可表示的最大值位2^16 - 1 = 65535。

  也就是说，Class文件中常量池的格式规定了，其字符串常量的长度不能超过65535。

  那么，尝试使用以下方式定义字符串：

  ```java
   String s = "11111...1111";//其中有65535个字符"1"
  ```

  尝试使用javac编译，同样会得到"错误: 常量字符串过长"，那么原因是什么呢？

  其实，这个原因在javac的代码中是可以找到的，在Gen类中有如下代码：

  ```java
  private void checkStringConstant(DiagnosticPosition var1, Object var2) {
      if (this.nerrs == 0 && var2 != null && var2 instanceof String && ((String)var2).length() >= 65535) {
          this.log.error(var1, "limit.string", new Object[0]);
          ++this.nerrs;
      }
  }
  ```

  代码中可以看出，当参数类型为String，并且长度大于等于65535的时候，就会导致编译失败。

  如果尝试以65534个字符定义字符串，则会发现可以正常编译。

  其实，关于这个值，在《Java虚拟机规范》也有过说明：

  > if the Java Virtual Machine code for a method is exactly 65535 bytes long and ends with an instruction that is 1 byte long, then that instruction cannot be protected by an exception handler. A compiler writer can work around this bug by limiting the maximum size of the generated Java Virtual Machine code for any method, instance initialization method, or static initializer (the size of any code array) to 65534 bytes

- **运行期限制**

  上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。

  那么，String在运行期有没有限制呢，答案是有的，就是前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）

  int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有：

  ```
  2^31-1 =2147483647 个 16-bit Unicodecharacter
  
  2147483647 * 16 = 34359738352 位
  34359738352 / 8 = 4294967294 (Byte)
  4294967294 / 1024 = 4194303.998046875 (KB)
  4194303.998046875 / 1024 = 4095.9999980926513671875 (MB)
  4095.9999980926513671875 / 1024 = 3.99999999813735485076904296875 (GB)
  ```

  有近 4G 的容量。

  很多人会有疑惑，编译的时候最大长度都要求小于65535了，运行期怎么会出现大于65535的情况呢。这其实很常见，如以下代码：

  ```java
  String s = "";
  for (int i = 0; i <100000 ; i++) {
      s+="i";
  }
  ```

  得到的字符串长度就有10万

- **总结**

  字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。

  在运行期，长度不能超过Int的范围，否则会抛异常。

### 自动拆装箱

#### 包装类型

Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。

包装类均位于 `java.lang` 包，包装类和基本数据类型的对应关系如下表所示：

| 基本数据类型 |  包装类   |
| :----------: | :-------: |
|     byte     |   Byte    |
|   boolean    |  Boolean  |
|    short     |   Short   |
|     char     | Character |
|     int      |  Integer  |
|     long     |   Long    |
|    float     |   Float   |
|    double    |  Double   |

在这八个类名中，除了 Integer 和 Character 类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。

#### 为什么需要包装类

因为 Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。

为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

#### 拆箱与装箱

那么，有了基本数据类型和包装类，肯定有些时候要在他们之间进行转换。比如把一个基本数据类型的 int 转换成一个包装类型的 Integer 对象。

我们认为包装类是对基本类型的包装，所以，把基本数据类型转换成包装类的过程就是打包装，英文对应于 boxing，中文翻译为装箱。

反之，把包装类转换成基本数据类型的过程就是拆包装，英文对应于 unboxing，中文翻译为拆箱。

在 Java SE5 之前，要进行装箱，可以通过以下代码：

```java
Integer i = new Integer(10);
```

#### 自动装箱与拆箱

在 Java SE5 中，为了减少开发人员的工作，Java 提供了自动拆箱与自动装箱功能。

自动装箱: 就是将基本数据类型自动转换成对应的包装类。

自动拆箱：就是将包装类自动转换成对应的基本数据类型。

```java
Integer i = 10;  //自动装箱
int b = i;     //自动拆箱
```

`Integer i=10` 可以替代 `Integer i = new Integer(10);`，这就是因为 Java 帮我们提供了自动装箱的功能，不需要开发者手动去 new 一个 Integer 对象。

#### 自动装箱与自动拆箱的实现原理

以下是自动拆装箱的代码：

```java
public static void main(String[]args) {
    Integer integer = 1; //装箱
    int i = integer; //拆箱
}
```

从上面反编译后的代码可以看出，int 的自动装箱都是通过 `Integer.valueOf()` 方法来实现的，Integer 的自动拆箱都是通过 `integer.intValue` 来实现的。

> 自动装箱都是通过包装类的 `valueOf()` 方法来实现的.自动拆箱都是通过包装类对象的 `xxxValue()` 来实现的。

#### 哪些地方会自动拆箱

- **场景一：将基本数据类型放入集合类**

  Java 中的集合类只能接收对象类型，那么以下代码为什么会不报错呢？

  ```java
  List<Integer> li = new ArrayList<>();
  for (int i = 1; i < 50; i ++) {
      li.add(i);
  }
  ```

  将上面代码进行反编译，可以得到以下代码：

  ```java
  List<Integer> li = new ArrayList<>();
  for (int i = 1; i < 50; i += 2){
      li.add(Integer.valueOf(i));
  }
  ```

  以上，我们可以得出结论，当我们把基本数据类型放入集合类中的时候，会进行自动装箱。

- **场景二：包装类型和基本类型的大小比较**

  当我们对 Integer 对象与基本类型进行大小比较的时候，实际上比较的是什么内容呢？看以下代码：

  ```java
  Integer a = 1;
  System.out.println(a == 1 ? "等于" : "不等于");
  Boolean bool = false;
  System.out.println(bool ? "真" : "假");
  ```

  对以上代码进行反编译，得到以下代码：

  ```java
  Integer a = 1;
  System.out.println(a.intValue() == 1 ? "等于" : "不等于");
  Boolean bool = false;
  System.out.println(bool.booleanValue() ? "真" : "假");
  ```

  可以看到，包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。

- **场景三：包装类型的运算**

  当我们对 Integer 对象进行四则运算的时候，是如何进行的呢？看以下代码：

  ```java
  Integer i = 10;
  Integer j = 20;
  System.out.println(i+j);
  ```

  反编译后代码如下：

  ```java
  Integer i = Integer.valueOf(10);
  Integer j = Integer.valueOf(20);
  System.out.println(i.intValue() + j.intValue());
  ```

  两个包装类型之间的运算，会被自动拆箱成基本类型进行。

- **场景四：三目运算符的使用**

  看一个简单的三目运算符的代码：

  ```java
  boolean flag = true;
  Integer i = 0;
  int j = 1;
  int k = flag ? i : j;
  ```

  其实在 `int k = flag ? i : j;` 这一行，会发生自动拆箱（ JDK1.8 之前，详见：[《阿里巴巴Java开发手册-泰山版》提到的三目运算符的空指针问题到底是个怎么回事？](https://www.hollischuang.com/archives/4749) ）。

  反编译后代码如下：

  ```java
  boolean flag = true;
  Integer i = Integer.valueOf(0);
  int j = 1;
  int k = flag ? i.intValue() : j;
  System.out.println(k);
  ```

  这其实是三目运算符的语法规范。当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。

  因为例子中，`flag ? i : j;` 片段中，第二段的 i 是一个包装类型的对象，而第三段的 j 是一个基本类型，所以会对包装类进行自动拆箱。如果这个时候 i 的值为 `null`，那么就会发生 NPE。（[自动拆箱导致空指针异常](http://www.hollischuang.com/archives/435)）

- **场景五：函数参数与返回值**

  代码：

  ```java
  //自动拆箱
  public int getNum1(Integer num) {
      return num;
  }
  //自动装箱
  public Integer getNum2(int num) {
      return num;
  }
  ```

#### 自动拆装箱带来的问题

当然，自动拆装箱是一个很好的功能，大大节省了开发人员的精力，不再需要关心到底什么时候需要拆装箱。但是，他也会引入一些问题。

> 包装对象的数值比较，不能简单的使用 `==`，虽然 -128 到 127 之间的数字可以，但是这个范围之外还是需要使用 `equals` 比较。
>
> 前面提到，有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为 null ，那么自动拆箱时就有可能抛出 NPE。
>
> 如果一个 for 循环中有大量拆装箱操作，会浪费很多资源。

#### 参考资料

[Java 的自动拆装箱](https://www.jianshu.com/p/cc9312104876)

### Integer的缓存机制

Java中Integer的缓存是在Java 5中引入的一个有助于节省内存、提高性能的功能。

使用Integer的示例代码：

```java
package com.javapapers.java;

public class JavaIntegerCache {
    public static void main(String... strings) {

        Integer integer1 = 3;
        Integer integer2 = 3;

        if (integer1 == integer2)
            System.out.println("integer1 == integer2");
        else
            System.out.println("integer1 != integer2");

        Integer integer3 = 300;
        Integer integer4 = 300;

        if (integer3 == integer4)
            System.out.println("integer3 == integer4");
        else
            System.out.println("integer3 != integer4");

    }
}
```

我们普遍认为上面的两个判断的结果都是 false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个 if 判断都是 false 的。在 Java 中，`==` 比较的是对象应用，而 `equals` 比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回 false。奇怪的是，这里两个类似的 if 条件判断返回不同的布尔值。

上面这段代码真正的输出结果：

```java
integer1 == integer2
integer3 != integer4
```

#### Java中Integer的缓存实现

在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。

> 适用于整数值区间 -128 至 +127。
>
> 只适用于自动装箱。使用构造函数创建对象不适用。

Java的编译器把基本数据类型自动转换成封装类对象的过程叫做`自动装箱`，相当于使用`valueOf`方法：

```java
Integer a = 10; //this is autoboxing
Integer b = Integer.valueOf(10); //under the hood
```

现在我们知道了这种机制在源码中哪里使用了，那么接下来我们就看看JDK中的`valueOf`方法。下面是`JDK 1.8.0 build 25`的实现：

```java
/**
 * Returns an {@code Integer} instance representing the specified
 * {@code int} value.  If a new {@code Integer} instance is not
 * required, this method should generally be used in preference to
 * the constructor {@link #Integer(int)}, as this method is likely
 * to yield significantly better space and time performance by
 * caching frequently requested values.
 *
 * This method will always cache values in the range -128 to 127,
 * inclusive, and may cache other values outside of this range.
 *
 * @param  i an {@code int} value.
 * @return an {@code Integer} instance representing {@code i}.
 * @since  1.5
 */
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
    	return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在创建对象之前先从IntegerCache.cache中寻找。如果没找到才使用new新建对象。

#### IntegerCache Class

IntegerCache是Integer类中定义的一个`private static`的内部类。接下来看看他的定义。

```java
/**
 * Cache to support the object identity semantics of autoboxing for values between
 * -128 and 127 (inclusive) as required by JLS.
 * <p>
 * The cache is initialized on first usage.  The size of the cache
 * may be controlled by the {@code -XX:AutoBoxCacheMax=} option.
 * During VM initialization, java.lang.Integer.IntegerCache.high property
 * may be set and saved in the private system properties in the
 * sun.misc.VM class.
 */
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);
            } catch (NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for (int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {
    }
}
```

其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过`-XX:AutoBoxCacheMax=size`修改。 缓存通过一个for循环实现。从低到高并创建尽可能多的整数并存储在一个整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。

实际上这个功能在Java 5中引入的时候，范围是固定的-128 至 +127。后来在Java 6中，可以通过`java.lang.Integer.IntegerCache.high`设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？因为这个范围的数字是最被广泛使用的。 在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。

#### Java语言规范中的缓存行为

在[Boxing Conversion](http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7)部分的Java语言规范(JLS)规定如下：

> 如果一个变量p的值是：
>
> -128至127之间的整数(§3.10.1)
>
> true 和 false的布尔值 (§3.10.3)
>
> ‘\u0000’至 ‘\u007f’之间的字符(§3.10.4)
>
> 中时，将p包装成a和b两个对象时，可以直接使用a==b判断a和b的值是否相等。

#### 其他缓存的对象

这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型的类都有类似的缓存机制。

> 有ByteCache用于缓存Byte对象
>
> 有ShortCache用于缓存Short对象
>
> 有LongCache用于缓存Long对象
>
> 有CharacterCache用于缓存Character对象

`Byte`, `Short`, `Long`有固定范围: -128 到 127。对于`Character`，范围是 0 到 127。除了`Integer`以外，这个范围都不能改变。

### 如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/isSuccess)

在日常开发中，我们会经常要在类中定义布尔类型的变量，比如在给外部系统提供一个RPC接口的时候，我们一般会定义一个字段表示本次请求是否成功的。

关于这个"本次请求是否成功"的字段的定义，其实是有很多种讲究和坑的，稍有不慎就会掉入坑里，到底该如何定一个布尔类型的成员变量。

一般情况下，我们可以有以下四种方式来定义一个布尔类型的成员变量：

```java
boolean success
boolean isSuccess
Boolean success
Boolean isSuccess
```

前两种和后两种的主要区别是变量的类型不同，前者使用的是boolean，后者使用的是Boolean。

另外，第一种和第三种在定义变量的时候，变量命名是success，而另外两种使用isSuccess来命名的。

#### success 还是 isSuccess

从语义上面来讲，两种命名方式都可以讲的通，并且也都没有歧义。

在阿里巴巴Java开发手册中关于这一点，有过一个『强制性』规定：

<img src="http://www.hollischuang.com/wp-content/uploads/2018/12/15449439364854.jpg" />

POJO中布尔类型变量不同的命名区别：

```java
class Model1  {
    private Boolean isSuccess;
    public void setSuccess(Boolean success) {
        isSuccess = success;
    }
    public Boolean getSuccess() {
        return isSuccess;
    }
 }

class Model2 {
    private Boolean success;
    public Boolean getSuccess() {
        return success;
    }
    public void setSuccess(Boolean success) {
        this.success = success;
    }
}

class Model3 {
    private boolean isSuccess;
    public boolean isSuccess() {
        return isSuccess;
    }
    public void setSuccess(boolean success) {
        isSuccess = success;
    }
}

class Model4 {
    private boolean success;
    public boolean isSuccess() {
        return success;
    }
    public void setSuccess(boolean success) {
        this.success = success;
    }
}
```

- 基本类型自动生成的getter和setter方法，名称都是`isXXX()`和`setXXX()`形式的。
- 包装类型自动生成的getter和setter方法，名称都是`getXXX()`和`setXXX()`形式的。

既然，我们已经达成一致共识使用基本类型boolean来定义成员变量了，那么我们再来具体看下Model3和Model4中的setter/getter有何区别。

我们可以发现，虽然Model3和Model4中的成员变量的名称不同，一个是success，另外一个是isSuccess，但是他们自动生成的getter和setter方法名称都是`isSuccess`和`setSuccess`。

**Java Bean中关于setter/getter的规范**

关于Java Bean中的getter/setter方法的定义其实是有明确的规定的，根据[JavaBeans(TM) Specification](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/)规定，如果是普通的参数propertyName，要以以下方式定义其setter/getter：

```java
public <PropertyType> get<PropertyName>();
public void set<PropertyName>(<PropertyType> a);
```

但是，布尔类型的变量propertyName则是单独定义的：

```java
public boolean is<PropertyName>();
public void set<PropertyName>(boolean m);
```

<img src="http://www.hollischuang.com/wp-content/uploads/2018/12/15449455942045.jpg" />

通过对照这份JavaBeans规范，我们发现，在Model4中，变量名为isSuccess，如果严格按照规范定义的话，他的getter方法应该叫isIsSuccess。但是很多IDE都会默认生成为isSuccess。

那这样做会带来什么问题呢。

在一般情况下，其实是没有影响的。但是有一种特殊情况就会有问题，那就是发生序列化的时候。

**序列化带来的影响**

关于序列化和反序列化请参考[Java对象的序列化与反序列化](http://www.hollischuang.com/archives/1150)。我们这里拿比较常用的JSON序列化来举例，看看看常用的fastJson、jackson和Gson之间有何区别：

```java
public class BooleanMainTest {
    public static void main(String[] args) throws IOException {
        //定一个Model3类型
        Model3 model3 = new Model3();
        model3.setSuccess(true);

        //使用fastjson(1.2.16)序列化model3成字符串并输出
        System.out.println("Serializable Result With fastjson :" + JSON.toJSONString(model3));

        //使用Gson(2.8.5)序列化model3成字符串并输出
        Gson gson =new Gson();
        System.out.println("Serializable Result With Gson :" +gson.toJson(model3));

        //使用jackson(2.9.7)序列化model3成字符串并输出
        ObjectMapper om = new ObjectMapper();
        System.out.println("Serializable Result With jackson :" +om.writeValueAsString(model3));
    }
}

class Model3 implements Serializable {
    private static final long serialVersionUID = 1836697963736227954L;
    private boolean isSuccess;
    public boolean isSuccess() {
        return isSuccess;
    }
    public void setSuccess(boolean success) {
        isSuccess = success;
    }
    public String getHollis(){
        return "hollischuang";
    }
}
```

以上代码的Model3中，只有一个成员变量即isSuccess，三个方法，分别是IDE帮我们自动生成的isSuccess和setSuccess，另外一个是自己增加的一个符合getter命名规范的方法。

以上代码输出结果：

```java
Serializable Result With fastjson :{"hollis":"hollischuang","success":true}
Serializable Result With Gson :{"isSuccess":true}
Serializable Result With jackson :{"success":true,"hollis":"hollischuang"}
```

在fastjson和jackson的结果中，原来类中的isSuccess字段被序列化成success，并且其中还包含hollis值。而Gson中只有isSuccess字段。

可以得出结论：fastjson和jackson在把对象序列化成json字符串的时候，是通过反射遍历出该类中的所有getter方法，得到getHollis和isSuccess，然后根据JavaBeans规则，他会认为这是两个属性hollis和success的值。直接序列化成json:{"hollis":"hollischuang","success":true}

但是Gson并不是这么做的，他是通过反射遍历该类中的所有属性，并把其值序列化成json:{"isSuccess":true}

可以看到，由于不同的序列化工具，在进行序列化的时候使用到的策略是不一样的，所以，对于同一个类的同一个对象的序列化结果可能是不同的。

前面提到的关于对getHollis的序列化只是为了说明fastjson、jackson和Gson之间的序列化策略的不同，暂且把他放到一边，把他从Model3中删除后，重新执行下以上代码，得到结果：

```java
Serializable Result With fastjson :{"success":true}
Serializable Result With Gson :{"isSuccess":true}
Serializable Result With jackson :{"success":true}
```

现在，不同的序列化框架得到的json内容并不相同，如果对于同一个对象，我使用fastjson进行序列化，再使用Gson反序列化会发生什么？

```java
public class BooleanMainTest {
    public static void main(String[] args) throws IOException {
        Model3 model3 = new Model3();
        model3.setSuccess(true);
        Gson gson =new Gson();
        System.out.println(gson.fromJson(JSON.toJSONString(model3),Model3.class));
    }
}

class Model3 implements Serializable {
    private static final long serialVersionUID = 1836697963736227954L;
    private boolean isSuccess;
    public boolean isSuccess() {
        return isSuccess;
    }
    public void setSuccess(boolean success) {
        isSuccess = success;
    }
    @Override
    public String toString() {
        return new StringJoiner(", ", Model3.class.getSimpleName() + "[", "]")
            .add("isSuccess=" + isSuccess)
            .toString();
    }
}
```

以上代码，输出结果：

```java
Model3[isSuccess=false]
```

这和预期的结果完全相反，原因是因为JSON框架通过扫描所有的getter后发现有一个isSuccess方法，然后根据JavaBeans的规范，解析出变量名为success，把model对象序列化城字符串后内容为`{"success":true}`。

根据`{"success":true}`这个json串，Gson框架在通过解析后，通过反射寻找Model类中的success属性，但是Model类中只有isSuccess属性，所以，最终反序列化后的Model类的对象中，isSuccess则会使用默认值false。

但是，一旦以上代码发生在生产环境，这绝对是一个致命的问题。

所以，作为开发者，应该想办法尽量避免这种问题的发生，对于POJO的设计者来说，只需要做简单的一件事就可以解决这个问题了，那就是把isSuccess改为success。这样，该类里面的成员变量是success，getter方法是isSuccess，这是完全符合JavaBeans规范的。无论哪种序列化框架，执行结果都一样。就从源头避免了这个问题。

所以，**在定义POJO中的布尔类型的变量时，不要使用isSuccess这种形式，而要直接使用success！**

#### Boolean还是boolean

boolean是基本数据类型，而Boolean是包装类型。关于基本数据类型和包装类之间的关系和区别请参考[一文读懂什么是Java中的自动拆装箱](http://www.hollischuang.com/archives/2700)

那么，在定义一个成员变量的时候到底是使用包装类型更好还是使用基本数据类型呢？

来看一段简单的代码

```java
 /**
 * @author Hollis
 */
public class BooleanMainTest {
    public static void main(String[] args) {
        Model model1 = new Model();
        System.out.println("default model : " + model1);
    }
}

class Model {
    /**
     * 定一个Boolean类型的success成员变量
     */
    private Boolean success;
    /**
     * 定一个boolean类型的failure成员变量
     */
    private boolean failure;

    /**
     * 覆盖toString方法，使用Java 8 的StringJoiner
     */
    @Override
    public String toString() {
        return new StringJoiner(", ", Model.class.getSimpleName() + "[", "]")
            .add("success=" + success)
            .add("failure=" + failure)
            .toString();
    }
}
```

以上代码输出结果为：

```java
default model : Model[success=null, failure=false]
```

可以看到，当没有设置Model对象的字段的值的时候，Boolean类型的变量会设置默认值为`null`，而boolean类型的变量会设置默认值为`false`。

即对象的默认值是`null`，boolean基本数据类型的默认值是`false`。

在阿里巴巴Java开发手册中，对于POJO中如何选择变量的类型也有着一些规定：

<img src="http://www.hollischuang.com/wp-content/uploads/2018/12/640.jpeg" />

这里建议使用包装类型，原因是什么呢？

举一个扣费的例子，做一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，预期该接口的返回值中会包含一个浮点型的费率字段。当取到这个值得时候就使用公式：金额*费率=费用 进行计算，计算结果进行划扣。

如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。

如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。

这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。

**以上，就是建议在POJO和RPC的返回值中使用包装类型的原因。**

但是关于这一点，作者之前也有过不同的看法：对于布尔类型的变量，我认为可以和其他类型区分开来，作者并不认为使用null进而导致NPE是一种最好的实践。因为布尔类型只有true/false两种值，完全可以和外部调用方约定好当返回值为false时的明确语义。

**尽量使用包装类型**

**尽量避免在你的代码中出现不确定的null值**

### 异常

#### Error和Exception

Exception和 Error，⼆者都是 Java异常处理的重要⼦类，各⾃都包含⼤量⼦类。均继承自Throwable类。

Error 表示系统级的错误，是java运⾏环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运⾏外别⽆选择，它是Java虚拟机抛出的。

Exception 表示程序需要捕捉、需要处理的常，是由与程序设计的不完善而出现的问题，程序必须处理的问题。

#### 异常类型

Java中的异常，主要可以分为两⼤类， 即受检异常（ checked exception） 和 非受检异常（ unchecked exception）

- **受检异常**

  对于受检异常来说，如果⼀个⽅法在声明的过程中证明了其要有受检异常抛出：

  ```java
  public void test() throw new Exception{ }
  ```

  那么，在程序中调⽤他的时候，⼀定要对该异常进⾏处理（ 捕获或者向上抛出），否则是⽆法编译通过的。这是⼀种强制规范。

  这种异常在IO操作中比较多。 ⽐如FileNotFoundException，当使用IO流处理⼀个⽂件的时候，有⼀种特殊情况，就是⽂件不存在，所以，在⽂件处理的接口定义时他会显示抛出FileNotFoundException，目的就是告诉这个⽅法的调用者，我这个⽅法不保证⼀定可以成功，是有可能找不到对应的⽂件的，你要明确的对这种情况做特殊处理。

  所以说，当我们希望我们的⽅法调用者，明确的处理⼀些特殊情况的时候，就应该使用受检异常。

- **非受检异常**

  对于非受检异常来说，⼀般是运行时异常，继承⾃RuntimeException。在编写代码的时候，不需要显示的捕获，但是如果不捕获，在运行期如果发⽣异常就会中断程序的执⾏。

  这种异常⼀般可以理解为是代码原因导致的。⽐如发⽣空指针、数组越界等。所以，只要代码写的没问题，这些异常都是可以避免的。也就不需要我们显示的进行处理。

  试想⼀下，如果你要对所有可能发生空指针的地方做异常处理的话，那相当于你的所有代码都需要做这件事。

#### 异常相关关键字

> try：⽤来指定⼀块预防所有异常的程序
>
> catch：catch子句紧跟在try块后面， 用来指定你想要捕获的异常的类型
>
> finally：为确保一段代码不管发生什么异常状况都要被执行
>
> throw：throw语句⽤来明确地抛出⼀个异常
>
> throws：用来声明⼀个方法可能抛出的各种异常

#### 正确处理异常

异常的处理⽅式有两种：

1. ⾃⼰处理
2. 向上抛，给调⽤者处理

异常，千万不能捕获了之后什么也不做或者只是使⽤`e.printStacktrace`

具体的处理⽅式的选择其实原则⽐较简明：自己明确的知道如何处理的，就要处理掉。不知道如何处理的，就交给调⽤者处理。

#### 自定义异常

⾃定义异常就是开发⼈员⾃⼰定义的异常， ⼀般通过继承`Exception`的⼦类的⽅式实现。

编写⾃定义异常类实际上是继承⼀个API标准异常类， ⽤新定义的异常处理信息覆盖原有信息的过程。

这种⽤法在Web开发中也⽐较常见， ⼀般可以⽤来⾃定义业务异常。 如余额不⾜、 重复提交等。 这种⾃定义异常有业务含义， 更容易让上层理解和处理

#### 异常链

“ 异常链” 是 Java 中⾮常流⾏的异常处理概念，是指在进⾏⼀个异常处理时抛出了另外⼀个异常，由此产⽣了⼀个异常链条。

该技术⼤多⽤于将“ 受检查异常” （checked exception）封装成为“⾮受检查异常”（unchecked exception）或者RuntimeException。

如果因为异常决定抛出⼀个新的异常，⼀定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()⽅法来访问异常最终的根源。

从 Java 1.4版本开始，几乎所有的异常都支持异常链。

以下是Throwable中支持异常链的方法和构造函数。

```java
Throwable getCause()
Throwable initCause(Throwable)
Throwable(String, Throwable)
Throwable(Throwable)
```

initCause和Throwable构造函数的Throwable参数是导致当前异常的异常。

getCause返回导致当前异常的异常，initCause设置当前异常的原因。

以下示例显示如何使用异常链：

```java
try {

} catch (IOException e) {
    throw new SampleException("Other IOException", e);
}
```

在此示例中，当捕获到IOException时，将创建一个新的SampleException异常，并附加原始的异常原因，并将异常链抛出到下一个更高级别的异常处理程序。

#### try-with-resources

#### finally和return的执行顺序

### 集合类

#### Collection和Collections区别

Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。是list，set等的父接口。

Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

#### Set和List的区别？

List,Set都是继承自Collection接口。都是用来存储一组相同类型的元素的。

List特点：元素有放入顺序，元素可重复 。

有顺序，即先放入的元素排在前面。

Set特点：元素无放入顺序，元素不可重复。

无顺序，即先放入的元素不一定排在前面。 不可重复，即相同元素在set中只会保留一份。所以，有些场景下，set可以用来去重。 不过需要注意的是，set在元素插入时是要有一定的方法来判断元素是否重复的。这个方法很重要，决定了set中可以保存哪些元素。

#### ArrayList和LinkedList和Vector的区别

List主要有ArrayList、LinkedList与Vector几种实现。

这三者都实现了List 接口，使用方式也很相似，主要区别在于因为实现方式的不同，所以对不同的操作具有不同的效率。

ArrayList 是一个可改变大小的数组。当更多的元素加入到ArrayList中时，其大小将会动态地增长。内部的元素可以直接通过get与set方法进行访问，因为ArrayList本质上就是一个数组。

LinkedList 是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。

当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比，如果数据和运算量很小，那么对比将失去意义。

Vector 和 ArrayList 类似，但属于强同步类。如果你的程序本身是线程安全的(thread-safe)，没有在多个线程之间共享同一个集合/对象)，那么使用 ArrayList 是更好的选择。

Vector 和ArrayList 在更多元素添加进来时会请求更大的空间。Vector 每次请求其大小的双倍空间，而 ArrayList 每次对size增长50%。

而 LinkedList 还实现了 Queue 接口，该接口比List提供了更多的方法，包括 offer()，peek()，poll()等。

注意：默认情况下 ArrayList 的初始容量非常小，所以如果可以预估数据量的话，分配一个较大的初始值属于最佳实践，这样可以减少调整大小的开销。

#### ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？

#### SynchronizedList和Vector的区别

#### Set如何保证元素不重复？

在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。

1、TreeSet 是二叉树实现的,Treeset中的数据是自动排好序的，不允许放入null值 2、HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束

在HashSet中，基本的操作都是有HashMap底层实现的，因为HashSet底层是用HashMap存储数据的。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。

TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。

TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。TreeSet是用compareTo()来判断重复元素的。

#### HashMap、HashTable、ConcurrentHashMap区别

#### HashMap的容量、扩容

#### HashMap中hash方法的原理

### I/O流

**分类：**

<img src="https://s1.ax1x.com/2020/10/28/B3ivSH.png" style="zoom: 67%;" />

**I/O 还可以根据操作对象来进行区分：**

<img src="https://s1.ax1x.com/2020/10/28/B3Fumq.png" style="zoom: 67%;" />

#### File对象

Java的标准库 `java.io` 提供了 `File` 对象来操作文件和目录。

要构造一个 `File` 对象，需要传入文件路径：

```java
public class FileDemo {
    public static void main(String[] args) {
        File file = new File("D:\\url");
        System.out.println(file);
    }
}
```

构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：

```java
File file = new File("C:\\Windows\\notepad.exe");
```

注意Windows平台使用 `\` 作为文件分隔符，在Java字符串中需要用 `\\` 表示一个 `\` 。Linux平台使用 `/` 作为文件分隔符：

```java
File file = new File("/usr/bin/javac");
```

注意Windows平台使用 `;` 作为文件分隔符，Linux平台使用 `:` 作为文件分隔符：

```java
//windows平台
system.out.println(File.pathSeparator);
//Linux平台
system.out.println(File.pathSeparator);
```

运行结果：

```
;
/
```

传入相对路径时，相对路径前面加上当前目录就是绝对路径：

```java
// 假设当前目录是C:\Docs
File f1 = new File("sub\\javac"); // 绝对路径是C:\Docs\sub\javac
File f3 = new File(".\\sub\\javac"); // 绝对路径是C:\Docs\sub\javac
File f3 = new File("..\\sub\\javac"); // 绝对路径是C:\sub\javac
```

可以用`.`表示当前目录，`..`表示上级目录。

File对象有3种形式表示的路径，一种是`getPath()`，返回构造方法传入的路径，一种是`getAbsolutePath()`，返回绝对路径，一种是`getCanonicalPath`，它和绝对路径类似，但是返回的是规范路径。

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        //当前项目所在路径
        System.out.println(System.getProperty("user.dir"));
        File file = new File("..");
        //构造方法传入的路径
        System.out.println(file.getPath());
        //绝对路径
        System.out.println(file.getAbsolutePath());
        //规范路径
        System.out.println(file.getCanonicalPath());
    }
}
```

运行结果：

```
D:\Study\项目\Java\Java习题
..
D:\Study\项目\Java\Java习题\..
D:\Study\项目\Java
```

绝对路径可以表示成`C:\Windows\System32\..\notepad.exe`，而规范路径就是把`.`和`..`转换成标准的绝对路径后的路径：`C:\Windows\notepad.exe`。

因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：

```java
System.out.println(File.separator); // 根据当前平台打印"\"或"/"
```

**文件和目录**

`File`对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个`File`对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个`File`对象，并不会导致任何磁盘操作。只有调用`File`对象的某些方法的时候，才真正进行磁盘操作。

调用`exist()`，判断该`File`对象是否存在文件或文件夹：

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("D:\\Study");
        //判断文件或文件夹是否存在
        System.out.println(file.exists());
    }
}
```

调用`isFile()`，判断该`File`对象是否是一个已存在的文件，调用`isDirectory()`，判断该`File`对象是否是一个已存在的目录：

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("..");
        //判断该File对象是否是一个已存在的文件
        System.out.println(file.isFile());
        //判断该File对象是否是一个已存在的目录
        System.out.println(file.isDirectory());
    }
}
```

用`File`对象获取到一个文件时，还可以进一步判断文件的权限和大小：

- `boolean canRead()`：是否可读
- `boolean canWrite()`：是否可写
- `boolean canExecute()`：是否可执行
- `long length()`：文件字节大小

对目录而言，是否可执行表示能否列出它包含的文件和子目录。

**创建和删除文件**

当File对象表示一个文件时，可以通过`createNewFile()`创建一个新文件，用`delete()`删除该文件：

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("D:\\url.txt");
        //创建和删除文件
        if (!file.exists()) {
            file.createNewFile();
        } else {
            file.delete();
        }
    }
}
```

File对象提供了`createTempFile()`来创建一个临时文件，以及`deleteOnExit()`在JVM退出时自动删除该文件。

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        //提供临时文件的前缀和后缀
        File file = File.createTempFile("tmp-", ".txt");
        //JVM退出时自动删除
        file.deleteOnExit();
    }
}
```

**遍历文件和目录**

当`File`对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。`listFiles()`提供了一系列重载方法，可以过滤不想要的文件和目录：

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        //遍历文件和目录
        listDirectories(new File("D:\\Study\\项目\\Java\\Java习题"));
        //仅列出.exe文件
        File f2 = new File("D:\\Study\\项目\\Java\\Java习题");
        File[] fs2 = f2.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".exe");
            }
        });
        printFiles(fs2);
    }
    
    public static void listDirectories(File dir) {
        File[] files = dir.listFiles();
        printFiles(files);
    }

    public static void printFiles(File[] files) {
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    listDirectories(file);
                }
                System.out.println(file);
            }
        }
    }
}
```

和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：

- `boolean mkdir()`：创建当前File对象表示的目录
- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来
- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功

#### 字符流与字节流

- **字节与字符**

  Bit最小的二进制单位 ，是计算机的操作部分。取值0或者1

  Byte（字节）是计算机操作数据的最小单位由8位bit组成。取值（-128-127）

  Char（字符）是用户的可读写的最小单位，在Java里面由16位bit组成。取值（0-65535）

- **字节流**

  操作byte类型数据，主要操作类是OutputStream、InputStream的子类；不用缓冲区，直接对文件本身操作。

- **字符流**

  操作字符类型数据，主要操作类是Reader、Writer的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。

- **互相转换**

  整个IO包实际上分为字节流和字符流，但是除了这两个流之外，还存在一组字节流-字符流的转换类。

  OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。

  InputStreamReader：是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。

#### 输入流与输出流

- **输入流**

  <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142HWK.png" />

  Java 流相关的类都封装在 java.io 包中，而且每个数据流都是一个对象。所有输入流类都是 InputStream 抽象类（字节输入流）和 Reader 抽象类（字符输入流）的子类。其中 InputStream 类是字节输入流的抽象类，是所有字节输入流的父类。

  <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115145253550.png" />

  <center>InputStream 类常用方法</center>

  | 名称                               | 作用                                                         |
  | ---------------------------------- | ------------------------------------------------------------ |
  | int read()                         | 从输入流读入一个 8 字节的数据，将它转换成一个 0~ 255 的整数，返回一个整数，如果遇到输入流的结尾返回 -1 |
  | int read(byte[] b)                 | 从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1 |
  | int read(byte[] b,int off,int len) | 从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1 |
  | void close()                       | 关闭数据流，当完成对数据流的操作之后需要关闭数据流           |
  | int available()                    | 返回可以从数据源读取的数据流的位数                           |
  | skip(long n)                       | 从输入流跳过参数 n 指定的字节数目                            |
  | boolean markSupported()            | 判断输入流是否可以重复读取，如果可以就返回 true              |
  | void mark(int readLimit)           | 如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数 |
  | void reset()                       | 使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据 |

  Java 中的字符是 Unicode 编码，即双字节的，而 InputerStream 是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用 Java 的文本输入流 Reader 类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法InputerSteam 类的方法类似。

- **输出流**

  <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142K1644.png" />

  在 Java 中所有输出流类都是 OutputStream 抽象类（字节输出流）和 Writer 抽象类（字符输出流）的子类。其中 OutputStream 类是字节输出流的抽象类，是所有字节输出流的父类。

  <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115151G3J0.png" />

  <center>OutputStream 类常用方法</center>

  | 名称                                 | 作用                                                     |
  | ------------------------------------ | -------------------------------------------------------- |
  | int write(b)                         | 将指定字节的数据写入到输出流                             |
  | int write (byte[] b)                 | 将指定字节数组的内容写入输出流                           |
  | int write (byte[] b,int off,int len) | 将指定字节数组从 off 位置开始的 len 字节的内容写入输出流 |
  | close()                              | 关闭数据流，当完成对数据流的操作之后需要关闭数据流       |
  | flush()                              | 刷新输出流，强行将缓冲区的内容写入输出流                 |

- **总结**

  输入、输出，有一个参照物，参照物就是存储数据的介质。如果是把对象读入到介质中，这就是输入。从介质中向外读数据，这就是输出。

  所以，输入流是把数据写入存储介质的。输出流是从存储介质中把数据读取出来。

#### 字节流和字符流之间的相互转换

想要实现字符流和字节流之间的相互转换需要用到两个类：

OutputStreamWriter 是字符流通向字节流的桥梁

InputStreamReader 是字节流通向字符流的桥梁

- **字符流转成字节流**

  ```java
  public static void main(String[] args) throws IOException {
      File file = new File("test.txt");
      //OutputStreamWriter是字符流通向字节流的桥梁,创建了一个字符流通向字节流的对象
      OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(file),"UTF-8");
      osw.write("我是字符流转换成字节流输出的");
      osw.close();
  }
  ```

- **字节流转成字符流**

  ```java
  public static void main(String[] args) throws IOException {
      File file = new File("test.txt");
      InputStreamReader inr = new InputStreamReader(new FileInputStream(file),"UTF-8");
      char[] buf = new char[1024];
      int len = inr.read(buf);
      System.out.println(new String(buf,0,len));
      inr.close();
  }
  ```

#### 同步与异步

#### 阻塞与非阻塞

#### Linux 5种IO模型

#### BIO、NIO和AIO的区别、三种IO的用法与原理

#### netty

### 反射

反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。

#### 反射有什么用

在运行时判断任意一个对象所属的类。

在运行时判断任意一个类所具有的成员变量和方法。

在运行时任意调用一个对象的方法

在运行时构造任意一个类的对象

#### Class类

Java的Class类是java反射机制的基础，通过Class类可以获得关于一个类的相关信息。

Java.lang.Class是一个比较特殊的类，它用于封装被装入到JVM中的类（包括类和接口）的信息。当一个类或接口被装入的JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。

虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。

#### 反射与工厂模式实现Spring IOC

- **反射机制概念**

  .java文件在编译后会变成.class文件，这就像是个镜面，本身是.java，在镜中是.class，他们其实是一样的；那么同理，看到镜子的反射是.class，就能通过反编译，了解到.java文件的本来面目。

  对于反射，官方给出的概念：反射是Java语言的一个特性，它允许程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。

  反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。

- **反射机制的作用**

  1. 在运行时判断任意一个对象所属的类
  2. 在运行时获取类的对象
  3. 在运行时访问java对象的属性，方法，构造方法等

  首先要搞清楚为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。

  静态编译：在编译时确定类型，绑定对象，即通过。

  动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。

- **反射机制的优缺点**

  反射机制的优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。

  反射机制的缺点：对性能有影响。使用反射基本上是一种解释操作，可以告诉JVM，希望做什么并且让它满足要求，这类操作总是慢于直接执行相同的操作。

- **反射与工厂模式实现IOC**

  Spring中的IOC的实现原理就是工厂模式加反射机制。 

  不用反射机制时的工厂模式：

  ```java
  interface Fruit{
      public abstract void eat();
  } 
  class Apple implements Fruit{
       public void eat(){
           System.out.println("Apple");
       }
  } 
  class Orange implements Fruit{
       public void eat(){
           System.out.println("Orange");
       }
  }
  //构造工厂类
  //也就是说以后如果在添加其他的实例的时候只需要修改工厂类就行了
  class Factory{
       public static Fruit getInstance(String fruitName){
           Fruit f=null;
           if("Apple".equals(fruitName)){
               f=new Apple();
           }
           if("Orange".equals(fruitName)){
               f=new Orange();
           }
           return f;
       }
  }
  class hello{
       public static void main(String[] a){
           Fruit f=Factory.getInstance("Orange");
           f.eat();
       }
  }
  ```

  上面写法的缺点是再添加一个子类的时候，就需要修改工厂类了。

  下面用反射机制实现工厂模式：

  ```java
  interface Fruit {
       public abstract void eat();
  }
  
  class Apple implements fruit {
  	public void eat() {
           System.out.println("Apple");
      }
  }
  
  class Orange implements fruit {
  	public void eat() {
          System.out.println("Orange");
      }
  }
  
  public class Factory {
      public static Fruit getInstance(String className) {
          Fruit f = null;
          try {
              f = (Fruit) Class.forName(className).newInstance();
          } catch (Exception e) {
              e.printStackTrace();
          }
          return f;
      }
  }
  
  class Hello {
      public static void main(String[] args) {
          Fruit f = Factory.getInstance("practice.反射..Apple");
          if (f != null) {
              f.eat();
          }
      }
  }
  ```

  使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以通过属性文件的形式配置所需要的子类。

  ```java
  apple=practice.反射.Apple
  orange=practice.反射.Orange
  ```

  ```java
  interface Fruit {
       public abstract void eat();
  }
  
  class Apple implements fruit {
  	public void eat() {
           System.out.println("Apple");
      }
  }
  
  class Orange implements fruit {
  	public void eat() {
          System.out.println("Orange");
      }
  }
  
  public class Init {
      public static Properties getPro() throws IOException {
          Properties properties = new Properties();
          File file = new File("src\\practice\\反射\\fruit.properties");
          if (file.exists()) {
              properties.load(new FileInputStream(file));
          } else {
              properties.setProperty("apple", "practice.反射.Apple");
              properties.setProperty("orange", "practice.反射.Orange");
              properties.store(new FileOutputStream(file), "FRUIT CLASS");
          }
          return properties;
      }
  }
  
  public class Factory {
      public static Fruit getInstance(String className) {
          Fruit f = null;
          try {
              f = (Fruit) Class.forName(className).newInstance();
          } catch (Exception e) {
              e.printStackTrace();
          }
          return f;
      }
  }
  
  class Hello {
      public static void main(String[] args) {
          Properties properties = Init.getPro();
          Fruit f = Factory.getInstance(properties.getProperty("apple"));
          if (f != null) {
              f.eat();
          }
      }
  }
  ```

- **IOC容器的技术剖析**

  IOC中最基本的技术就是“反射(Reflection)”编程，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要生产的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。

  可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。

- **使用IOC框架应该注意什么**

  使用IOC框架产品能够给开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。

  1. 软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。
  2. 由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果要追求运行效率的话，就必须对此进行权衡。
  3. 具体到IOC框架产品（比如Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。
  4. IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。

  大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。

### 枚举

#### 枚举的用法

- **背景**

  在`java`语言中还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组具有`int`常量。

  通常利用`public final static` 方法定义的代码如下，分别用1表示春天，2表示夏天，3表示秋天，4表示冬天：

  ```java
  public class Season {
      public static final int SPRING = 1;
      public static final int SUMMER = 2;
      public static final int AUTUMN = 3;
      public static final int WINTER = 4;
  }
  ```

  这种方法称作int枚举模式，当然**这种模式不是类型安全的**。

- **定义**

  枚举类型（`enum type`）是指由一组固定的常量组成合法的类型。

  `Java`中由关键字`enum`来定义一个枚举类型。

  `Java`枚举类型的定义：

  ```java
  public enum Season {
      SPRING, SUMMER, AUTUMN, WINTER;
  }
  ```

- **特点**

  > 使用关键字`enum` 
  >
  > 类型名称，比如这里的`Season`
  >
  > 一串允许的值，比如上面定义的春夏秋冬四季
  >
  > 枚举可以单独定义在一个文件中，也可以嵌在其它`Java`类中
  >
  > 枚举可以实现一个或多个接口（Interface）
  >
  > 可以定义新的变量
  >
  > 可以定义新的方法
  >
  > 可以定义根据具体枚举值而相异的类

- **应用场景**

  ```java
  public enum Season {
      SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);
      private int code;
  
      Season(int code) {
          this.code = code;
      }
  
      public int getCode() {
          return code;
      }
  }
  
  public class UseSeason {
      /**
       * 将英文的季节转换成中文季节
       *
       * @param season
       * @return
       */
      public String getChineseSeason(Season season) {
          StringBuffer result = new StringBuffer();
          switch (season) {
              case SPRING:
                  result.append("[中文：春天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                  break;
              case AUTUMN:
                  result.append("[中文：秋天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                  break;
              case SUMMER:
                  result.append("[中文：夏天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                  break;
              case WINTER:
                  result.append("[中文：冬天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                  break;
              default:
                  result.append("地球没有的季节 " + season.name());
                  break;
          }
          return result.toString();
      }
  
      public void doSomething() {
          for (Season s : Season.values()) {
              System.out.println(getChineseSeason(s));//这是正常的场景
          }
          //System.out.println(getChineseSeason(5));
          //此处已经是编译不通过了，这就保证了类型安全
      }
  
      public static void main(String[] arg) {
          UseSeason useSeason = new UseSeason();
          useSeason.doSomething();
      }
  }
  ```

  运行结果：

  ```java
  [中文：春天，枚举常量:SPRING，数据:1]
  [中文：夏天，枚举常量:SUMMER，数据:2]
  [中文：秋天，枚举常量:AUTUMN，数据:3]
  [中文：冬天，枚举常量:WINTER，数据:4]
  ```

- **用法**

  - **常量**

    ```java
    public enum Color {  
      RED, GREEN, BLANK, YELLOW  
    }
    ```

  - **switch**

    ```java
    public class TrafficLight {
        Signal color = Signal.RED;
    
        public void change() {
            switch (color) {
                case RED:
                    color = Signal.GREEN;
                    break;
                case YELLOW:
                    color = Signal.RED;
                    break;
                case GREEN:
                    color = Signal.YELLOW;
                    break;
            }
        }
    }
    ```

  - **向枚举中添加新方法**

    ```java
    public enum Color {
        RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);
        private String name;
        private int index;
    
        Color(String name, int index) {
            this.name = name;
            this.index = index;
        }
    
        public static String getName(int index) {
            for (Color c : Color.values()) {
                if (c.getIndex() == index) {
                    return c.name;
                }
            }
            return null;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getIndex() {
            return index;
        }
    
        public void setIndex(int index) {
            this.index = index;
        }
    
        @Override
        public String toString() {
            return this.index + "_" + this.name;
        }
    }
    ```

  - **覆盖枚举的方法**

    ```java
    public enum Color {  
        RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
        // 成员变量  
        private String name;  
        private int index;  
        // 构造方法  
        private Color(String name, int index) {  
            this.name = name;  
            this.index = index;  
        }  
        //覆盖方法  
        @Override  
        public String toString() {  
            return this.index+"_"+this.name;  
        }  
    }  
    
    ```

  - **实现接口**

    ```java
    public interface Behaviour {  
        void print();  
        String getInfo();  
    }  
    public enum Color implements Behaviour{  
        RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
        // 成员变量  
        private String name;  
        private int index;  
        // 构造方法  
        private Color(String name, int index) {  
            this.name = name;  
            this.index = index;  
        }  
    //接口方法  
        @Override  
        public String getInfo() {  
            return this.name;  
        }  
        //接口方法  
        @Override  
        public void print() {  
            System.out.println(this.index+":"+this.name);  
        }  
    }  
    ```

  - **使用接口组织枚举**

    ```java
    public interface Food {
        enum Coffee implements Food {
            BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO
        }
    
        enum Dessert implements Food {
            FRUIT, CAKE, GELATO
        }
    }
    ```

#### 枚举的实现

枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢？

简单枚举例子：

```java
public enum t {
    SPRING,SUMMER;
}
```

使用反编译代码内容如下：

```java
public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER
        });
    }
}
```

通过反编译后，public final class T extends Enum，说明了该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。

当使用enum来定义一个枚举类型的时候，编译器会自动创建一个final类型的类继承Enum类，所以枚举类型不能被继承。

#### 枚举与单例

#### Enum类

Java中定义枚举是使用enum关键字的，但是Java中其实还有一个java.lang.Enum类。这是一个抽象类，定义如下：

```java
package java.lang;

public abstract class Enum<E extends Enum<E>> implements Constable, Comparable<E>, Serializable {
    private final String name;
    private final int ordinal;

}
```

这个类在日常开发中不会用到，但是其实使用enum定义的枚举，其实现方式就是通过继承Enum类实现的。

当使用enum来定义一个枚举类型的时候，编译器会自动帮创建一个final类型的类继承Enum类，所以枚举类型不能被继承。

#### Java枚举如何比较

java 枚举值比较用 == 和 equals 方法没啥区别，两个随便用都是一样的效果。

因为枚举 Enum 类的 equals 方法默认实现就是通过 == 来比较的；

类似的 Enum 的 compareTo 方法比较的是 Enum 的 ordinal 顺序大小；

类似的还有 Enum 的 name 方法和 toString 方法一样都返回的是 Enum 的 name 值。

#### switch对枚举的支持

Java 1.7 之前 switch 参数可用类型为 short、byte、int、char，枚举类型之所以能使用其实是编译器层面实现的

编译器会将枚举 switch 转换为类似

```java
switch(s.ordinal()) { 
    case Status.START.ordinal() 
}
```

形式，所以实质还是 int 参数类型。

#### 枚举的序列华如何实现

#### 枚举的线程安全性问题

### 泛型

#### 什么是泛型？

Java 泛型（ generics） 是JDK 5中引⼊的⼀个新特性，允许在定义类和接口的时候使⽤类型参数（ type parameter）。

声明的类型参数在使⽤时⽤具体的类型来替换， 泛型最主要的应⽤是在JDK 5中的新集合类框架中。

泛型最⼤的好处是可以提⾼代码的复⽤性。

#### 类型擦除

- **各种语言的编译器是如何处理泛型的**

  通常情况下，一个编译器处理泛型有两种方式：

  1. `Code specialization`

     在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型`list`，可能需要针对`string`，`integer`，`float`产生三份目标代码。

  2. `Code sharing`

     对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。

  **C++**中的模板（`template`）是典型的`Code specialization`实现。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中`integer list`和`string list`是两种不同的类型，这样会导致**代码膨胀（code bloat）**。**C#**里面泛型无论在程序源码中、编译后的`IL`中（Intermediate Language，中间语言，这时候泛型是一个占位符）或是运行期的CLR中都是切实存在的，`List<int>`与`List<String>`就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为**类型膨胀**，基于这种方法实现的泛型被称为**`真实泛型`**。 Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的**原生类型（Raw Type，也称为裸类型）**了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，`ArrayList<int>`与`ArrayList<String>`就是同一个类。所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为**类型擦除**，基于这种方法实现的泛型被称为**`伪泛型`**。

  `C++`和`C#`是使用`Code specialization`的处理机制，前面提到，他有一个缺点，那就是会导致**代码膨胀**。另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用`Code sharing`方式处理泛型的主要原因。

  `Java`编译器通过`Code sharing`方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过**类型擦除**（`type erasue`）实现的。

- **什么是类型擦除**

  > 类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下：
  >
  > 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换
  >
  > 移除所有的类型参数

- **Java编译器处理泛型的过程**

  **code 1：**

  ```java
  public static void main(String[] args) {  
      Map<String, String> map = new HashMap<String, String>();  
      map.put("name", "hollis");  
      map.put("age", "22");  
      System.out.println(map.get("name"));  
      System.out.println(map.get("age"));  
  }  
  ```

  **反编译后的code 1：**

  ```java
  public static void main(String[] args) {  
      Map map = new HashMap();  
      map.put("name", "hollis");  
      map.put("age", "22"); 
      System.out.println((String) map.get("name"));  
      System.out.println((String) map.get("age"));  
  }
  ```

  发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型。

  **code 2：**

  ```java
  interface Comparable<A> {
      public int compareTo(A that);
  }
  
  public final class NumericValue implements Comparable<NumericValue> {
      private byte value;
  
      public NumericValue(byte value) {
          this.value = value;
      }
  
      public byte getValue() {
          return value;
      }
  
      public int compareTo(NumericValue that) {
          return this.value - that.value;
      }
  }
  ```

  **反编译后的code 2：**

  ```java
  interface Comparable {
    public int compareTo(Object that);
  } 
  
  public final class NumericValue implements Comparable {
      public NumericValue(byte value) {
          this.value = value;
      }
      public byte getValue() {
          return value;
      }
      public int compareTo(NumericValue that) {
          return value - that.value;
      }
      public volatile int compareTo(Object obj) {
          return compareTo((NumericValue)obj);
      }
      private byte value;
  }
  ```

  **code 3：**

  ```java
  public class Collections {
      public static <A extends Comparable<A>> A max(Collection<A> xs) {
          Iterator<A> xi = xs.iterator();
          A w = xi.next();
          while (xi.hasNext()) {
              A x = xi.next();
              if (w.compareTo(x) < 0)
                  w = x;
          }
          return w;
      }
  }
  ```

  **反编译后的code 3：**

  ```java
  public class Collections {
      public Collections() {
          
      }
      public static Comparable max(Collection xs) {
          Iterator xi = xs.iterator();
          Comparable w = (Comparable)xi.next();
          while(xi.hasNext()) {
              Comparable x = (Comparable)xi.next();
              if(w.compareTo(x) < 0)
                  w = x;
          }
          return w;
      }
  }
  ```

  第2个泛型类`Comparable <A>`擦除后 A被替换为最左边界`Object`。`Comparable<NumericValue>`的类型参数`NumericValue`被擦除掉，但是这直接导致`NumericValue`没有实现接口`Comparable的compareTo(Object that)`方法，于是编译器充当好人，添加了一个**桥接方法**。 第3个示例中限定了类型参数的边界`<A extends Comparable<A>> A`，A必须为`Comparable<A>`的子类，按照类型擦除的过程，先讲所有的类型参数替换为最左边界`Comparable<A>`，然后去掉参数类型`A`，得到最终的擦除后结果。

- **总结**

  1.虚拟机中没有泛型，只有普通类和普通方法,所有泛型类的类型参数在编译时都会被擦除,泛型类并没有自己独有的Class类对象。比如并不存在`List<String>`.class或是`List<Integer>.class`，而只有`List.class`。 2.创建泛型对象时请指明类型，让编译器尽早的做参数检查（**Effective Java，第23条：请不要在新代码中使用原生态类型**） 3.不要忽略编译器的警告信息，那意味着潜在的`ClassCastException`等着你。 4.静态变量是被泛型类的所有实例所共享的。对于声明为`MyClass<T>`的类，访问其中的静态变量的方法仍然是 `MyClass.myStaticVar`。不管是通过`new MyClass<String>`还是`new MyClass<Integer>`创建的对象，都是共享一个静态变量。 5.泛型的类型参数不能用在`Java`异常处理的`catch`语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，`JVM`是无法区分两个异常类型`MyException<String>`和`MyException<Integer>`的。对于`JVM`来说，它们都是 `MyException`类型的。也就无法执行与异常对应的`catch`语句。

#### 泛型带来的问题

- **当泛型遇到重载**

  ```java
  public class GenericTypes {  
  
      public static void method(List<String> list) {  
          System.out.println("invoke method(List<String> list)");  
      }  
  
      public static void method(List<Integer> list) {  
          System.out.println("invoke method(List<Integer> list)");  
      }  
  }  
  ```

  上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是`List<String>`另一个是`List<Integer>` ，但是，这段代码是编译通不过的。因为参数`List<Integer>`和`List<String>`编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。

- **当泛型遇到catch**

  如果自定义了一个泛型异常类GenericException，那么，不要尝试用多个catch取匹配不同的异常类。

  例如想要分别捕获GenericException、GenericException，这也是有问题的。

- **当泛型内包含静态变量**

  ```java
  public class StaticTest {
      public static void main(String[] args) {
          GT<Integer> gti = new GT<>();
          gti.var = 1;
          GT<String> gts = new GT<>();
          gts.var = 2;
          System.out.println(gti.var);
      }
  }
  
  class GT<T> {
      public static int var = 0;
  
      public void nothing(T x) {
      }
  }
  ```

  答案是——2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。

#### 泛型中K T V E ? object等的含义

E - Element (在集合中使用，因为集合中存放的是元素)

T - Type（Java 类）

K - Key（键）

V - Value（值）

N - Number（数值类型）

？- 表示不确定的java类型（无限制通配符类型）

S、U、V - 2nd、3rd、4th types

Object - 是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。

#### 限定通配符和非限定通配符

`限定通配符`对类型进⾏限制，泛型中有两种限定通配符：

表示类型的上界，格式为：<？extends T>，即类型必须为T类型或者T子类

表示类型的下界，格式为：<？super T>，即类型必须为T类型或者T的父类

泛型类型必须⽤限定内的类型来进⾏初始化，否则会导致编译错误。

`⾮限定通配符`表⽰可以⽤任意泛型类型来替代，类型为\<T>

#### 上下界限定符extends 和 super

`<? extends T>`和`<? super T>`是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。

`<? extends T>`：是指 “上界通配符（Upper Bounds Wildcards）”，即泛型中的类必须为当前类的子类或当前类。

`<? super T>`：是指 “下界通配符（Lower Bounds Wildcards）”，即泛型中的类必须为当前类或者其父类。

示例代码：

```java
public class Food {}
public class Fruit extends Food {}
public class Apple extends Fruit {}
public class Banana extends Fruit{}

public class GenericTest {

    public void testExtends(List<? extends Fruit> list) {

        //报错：extends为上界通配符,只能取值,不能放.
        //因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错
        //list.add(new Apple());

        //可以正常获取
        Fruit fruit = list.get(1);
    }

    public void testSuper(List<? super Fruit> list) {

        //super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲
        //无法确定Fruit的父类是否只有Food一个(Object是超级父类)
        //因此放入Food的实例编译不通过
        list.add(new Apple());
//        list.add(new Food());

        Object object = list.get(1);
    }
}
```

在testExtends方法中，因为泛型中用的是extends，在向list中存放元素的时候，并不能确定List中的元素的具体类型，即可能是Apple也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。

在testSuper方法中，因为泛型中用的是super，即不能确定方法参数中的泛型是Fruit的哪个父类，因此在调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型(本例子中为Fruit)，范围更小。

在使用泛型时，存取元素时用super，获取元素时，用extends。

频繁往外读取内容的，适合用上界Extends。经常往里插入的，适合用下界Super。

#### List\<Object>和原始类型List之间的区别?

原始类型List和带参数类型`List<Object>`之间的主要区别是：

在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。

通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。

它们之间的第二点区别是：

可以把任何带参数的类型传递给原始类型List，但却不能把`List<String>`传递给接受 `List<Object>`的方法，因为会产生编译错误。

#### List<?>和List\<Object>之间的区别是什么?

`List<?>` 是一个未知类型的List，而`List<Object>` 其实是任意类型的List。

你可以把`List<String>`, L`ist<Integer>`赋值给`List<?>`，却不能把`List<String>`赋值给 `List<Object>`。

### 动态代理

#### 静态代理

所谓静态代理，就是代理类是由程序员自己编写的，在编译期就确定好了的。

例子：

```java
public interface HelloService {
    public void say();
}

public class HelloServiceImpl implements HelloSerivice {

    @Override
    public void say() {
        System.out.println("hello world");
    }
}
```

上面的代码定义了一个接口和其实现类，这就是代理模式中的目标对象和目标对象的接口。

类定义代理对象：

```java
public class HelloServiceProxy implements HelloService {

    private HelloService target;
    public HelloServiceProxy(HelloService target) {
        this.target = target;
    }

    @Override
    public void say() {
        System.out.println("记录日志");
        target.say();
        System.out.println("清理数据");
    }
}
```

上面是一个代理类，也实现了目标对象的接口，并且扩展了say方法。

下面是一个测试类：

```java
public class Main {
    @Test
    public void testProxy() {
        //目标对象
        HelloService target = new HelloServiceImpl();
        //代理对象
        HelloServiceProxy proxy = new HelloServiceProxy(target);
        proxy.say();
    }
}
```

运行结果：

```java
记录日志
hello world
清理数据
```

代理模式中的所有角色（代理对象、目标对象、目标对象的接口）等都是在编译期就确定好的。

静态代理的用途：

- 控制真实对象的访问权限，通过代理对象控制对真实对象的使用权限。

- 避免创建大对象，通过使用一个代理小对象来代表一个真实的大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。

- 增强真实对象的功能，通过代理可以在调用真实对象的方法的前后增加额外功能。

#### 动态代理

虽然静态代理模式很好用，但是静态代理还是存在一些局限性的，比如使用静态代理模式需要程序员手写很多代码，这个过程是比较浪费时间和精力的。一旦需要代理的类中方法比较多，或者需要同时代理多个对象的时候，这无疑会增加很大的复杂度。

动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能。

#### 动态代理和反射的关系

反射是动态代理的一种实现方式。

#### 动态代理的几种实现方式

Java中，实现动态代理有两种方式：

1. JDK动态代理：java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。
2. Cglib动态代理：Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。

- **JDK动态代理和Cglib动态代理的区别**

  JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口，如果想代理没有实现接口的类，就可以使用CGLIB实现。

  Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。

  Cglib包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。

  Cglib与动态代理最大的区别就是：

  使用动态代理的对象必须实现一个或多个接口

  使用cglib代理的对象则无需实现接口，达到代理类无侵入。

- **Java实现动态代理的大致步骤**

  1. 定义一个委托类和公共接口。
  2. 自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类。
  3. 生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。

- **Java 实现动态代理主要涉及哪几个类**

  java.lang.reflect.Proxy：这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。

  java.lang.reflect.InvocationHandler：这里称他为"调用处理器"，它是一个接口，动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。

- **动态代理实现**

  使用动态代理实现功能：不改变Test类的情况下，在方法 target 之前打印一句话，之后打印一句话。

  ```java
  public class UserServiceImpl implements UserService {
  
      @Override
      public void add() {
          // TODO Auto-generated method stub
          System.out.println("--------------------add----------------------");
      }
  }
  ```

- **JDK动态代理**

  ```java
  public class MyInvocationHandler implements InvocationHandler {
  
      private Object target;
  
      public MyInvocationHandler(Object target) {
          super();
          this.target = target;
  
      }
  
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          PerformanceMonior.begin(target.getClass().getName()+"."+method.getName());
          //System.out.println("-----------------begin "+method.getName()+"-----------------");
          Object result = method.invoke(target, args);
          //System.out.println("-----------------end "+method.getName()+"-----------------");
          PerformanceMonior.end();
          return result;
      }
  
      public Object getProxy() {
          return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), this);
      }
  }
  
  public static void main(String[] args) {
        UserService service = new UserServiceImpl();
        MyInvocationHandler handler = new MyInvocationHandler(service);
        UserService proxy = (UserService) handler.getProxy();
        proxy.add();
  }
  ```

- **cglib动态代理**

  ```java
  public class CglibProxy implements MethodInterceptor{  
      private Enhancer enhancer = new Enhancer();
  
      public Object getProxy(Class clazz) {
          //设置需要创建子类的类  
          enhancer.setSuperclass(clazz);
          enhancer.setCallback(this);
          //通过字节码技术动态创建子类实例  
          return enhancer.create();
      }
  
      //实现MethodInterceptor接口方法  
      public Object intercept(Object obj, Method method, Object[] args,
                              MethodProxy proxy) throws Throwable {
          System.out.println("前置代理");
          //通过代理类调用父类中的方法  
          Object result = proxy.invokeSuper(obj, args);
          System.out.println("后置代理");
          return result;
      }
  }  
  
  public class DoCGLib {  
      public static void main(String[] args) {
          CglibProxy proxy = new CglibProxy();
          //通过生成子类的方式创建代理类  
          UserServiceImpl proxyImp = (UserServiceImpl) proxy.getProxy(UserServiceImpl.class);
          proxyImp.add();
      }
  }
  ```

#### AOP

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。

JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。

如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。

CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

### 序列化

#### 什么是序列化与反序列化

序列化是将对象转换为可传输格式的过程。是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。

反序列化是序列化的逆操作。

序列化是将对象的状态信息转换为可存储或传输的形式的过程。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。

#### Java如何实现序列化与反序列化

- **Java对象的序列化与反序列化** 

  在Java中，可以通过多种方式来创建对象，并且只要对象没有被回收都可以复用该对象。但是，创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。

  对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。

  在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。

- **相关接口及类**

  > java.io.Serializable
  >
  > java.io.Externalizable
  >
  > ObjectOutput
  >
  > ObjectInput
  >
  > ObjectOutputStream
  >
  > ObjectInputStream

- **Serializable 接口**

  类通过实现`java.io.Serializable`接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。**序列化接口没有方法或字段，仅用于标识可序列化的语义。**

  当试图对一个对象进行序列化的时候，如果遇到不支持`Serializable`接口的对象。在此情况下，将抛出`NotSerializableException`。

  如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成`java.io.Serializable`接口。

  一个实现了`java.io.Serializable`接口的类：

  ```java
  import java.io.Serializable;
  
  public class User1 implements Serializable {
      private String name;
      private int age;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  ```

  通过下面的代码进行序列化及反序列化：

  ```java
  import java.io.*;
  
  public class SerializableDemo1 {
      public static void main(String[] args) {
          User1 user = new User1();
          user.setName("hollis");
          user.setAge(23);
          System.out.println(user);
  
          ObjectOutputStream oos = null;
          try {
              oos = new ObjectOutputStream(new FileOutputStream("\tempFile"));
              oos.writeObject(user);
          } catch (IOException e) {
              e.printStackTrace();
          }
  
          File file = new File("tempFile");
          ObjectInputStream ois = null;
          try {
              ois = new ObjectInputStream(new FileInputStream(file));
              User1 newUser = (User1) ois.readObject();
              System.out.println(newUser);
          } catch (IOException e) {
              e.printStackTrace();
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- **Externalizable接口**

除了`Serializable`之外，java中还提供了另一个序列化接口`Externalizable`。

为了了解Externalizable接口和Serializable接口的区别，先来看代码，把上面的代码改成使用`Externalizable`的形式。

```java
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

public class User1 implements Externalizable {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void writeExternal(ObjectOutput out) throws IOException {
    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    }

    @Override
    public String toString() {
        return "User{" +
        "name='" + name + '\'' +
        ", age=" + age +
        '}';
        }
    }
}
```

```java
import java.io.*;

public class ExternalizableDemo1 {
    //为了便于理解和节省篇幅， 忽略关闭流操作及删除文件操作。 真正编码时千万不要忘记
    //IOException 直接抛出
    public static void main(String[] args) throws IOException, ClassNotFoundException {
    //Write Obj to file序列化
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
        User1 user = new User1();
        user.setName("william");
        user.setAge(23);
        oos.writeObject(user);
        //Read Obj from file
        File file = new File("tempFile");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        User1 newInstance = (User1) ois.readObject();
        //output
        System.out.println(newInstance);
    }
}
//OutPut:
//User{name='null', age=0}
```

通过上面的实例可以发现，对User1类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是`Externalizable`接口和`Serializable`接口的区别：

Externalizable继承了Serializable，该接口中定义了两个抽象方法：`writeExternal()`与`readExternal()`。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写`writeExternal()`与`readExternal()`方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。

按照要求修改之后代码如下：

```java
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

public class User2 implements Externalizable {
    private String name;
    private int age;

    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
    }

    @Override
    public String toString() {
        return "User{" +
        "name='" + name + '\'' +
        ", age=" + age +
        '}';
    }
}
```

这样就可以把之前的对象状态持久化下来了。

如果`User`类中没有无参数的构造函数，在运行时会抛出异常：`java.io.InvalidClassException`

- **参考资料**

  [维基百科](https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96)

  [理解Java对象序列化](https://www.ibm.com/developerworks/cn/java/j-lo-serial/)

#### Serializable 和 Externalizable 有何不同

#### serialVersionUID

#### 为什么serialVersionUID不能随便改

#### transient

#### 序列化底层原理

#### 序列化如何破坏单例模式

#### protobuf

#### Apache-Commons-Collections的反序列化漏洞

#### fastjson的反序列化漏洞

### 注解

### 单元测试

#### JUnit

JUnit 是一个 Java 语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。它由肯特·贝克和埃里希·伽玛（Erich Gamma）建立，逐渐成为源于 Kent Beck 的 sUnit 的 xUnit 家族中为最成功的一个。JUnit有它自己的JUnit扩展生态圈。

JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。

特点：

- JUnit 是一个开放的资源框架，用于编写和运行测试。
- 提供注释来识别测试方法。
- 提供断言来测试预期结果。
- 提供测试运行来运行测试。
- JUnit 测试允许你编写代码更快，并能提高质量。
- JUnit 优雅简洁。没那么复杂，花费时间较少。
- JUnit 测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。
- JUnit 测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。
- JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。 JUnit知识经常 和测试驱动开发的讨论融合在一起。可以参考Kent Beck的 《Test-Driven Development: By Example》一书（有中文版和影印版）。

**什么是单元测试用例？**

单元测试用例是一部分代码，可以确保另一端代码（方法）按预期工作。为了迅速达到预期的结果，就需要测试框架。

一个正式的编写好的单元测试用例的特点是：已知输入和预期输出，即在测试执行前就已知。已知输入需要测试的先决条件，预期输出需要测试后置条件。

每一项需求至少需要两个单元测试用例：一个正检验，一个负检验。如果一个需求有子需求，每一个子需求必须至少有正检验和负检验两个测试用例。

### API&SPI

### 时间处理

#### 时区

时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时） 。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。

世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。

为了照顾到各地区的使用方便，又使其他地方的人容易将本地的时间换算到别的地方时间上去。有关国际会议决定将地球表面按经线从东到西，划成一个个区域，并且规定相邻区域的时间相差1小时。在同一区域内的东端和西端的人看到太阳升起的时间最多相差不过1小时。当人们跨过一个区域，就将自己的时钟校正1小时（向西减1小时，向东加1小时），跨过几个区域就加或减几小时。这样使用起来就很方便。现今全球共分为24个时区。由于实用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。

北京时间比洛杉矶时间早15或者16个小时。具体和时令有关。北京时间比纽约时间早12或者13个小时。具体和时令有关。

#### 冬令时和夏令时

夏令时、冬令时的出现，是为了充分利用夏天的日照，所以时钟要往前拨快一小时，冬天再把表往回拨一小时。其中夏令时从3月第二个周日持续到11月第一个周日。

- **冬令时**

  北京和洛杉矶时差：16
  
  北京和纽约时差：13

- **夏令时**

  北京和洛杉矶时差：15
  
  北京和纽约时差：12

#### 时间戳

时间戳（timestamp），一个能表示一份数据在某个特定时间之前已经存在的、 完整的、 可验证的数据，通常是一个字符序列，唯一地标识某一刻的时间。

时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。通俗的讲， 时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。

#### 格林威治时间

格林尼治平时（英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。

自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。

格林尼治平时的正午是指当平太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被原子钟报时的协调世界时（UTC）所取代。

一般使用GMT+8表示中国的时间，是因为中国位于东八区，时间上比格林威治时间快8个小时。

#### CET,UTC,GMT,CST几种常见时间的含义和关系

**CET**

欧洲中部时间（英語：Central European Time，CET）是比世界标准时间（UTC）早一个小时的时区名称之一。它被大部分欧洲国家和部分北非国家采用。冬季时间为UTC+1，夏季欧洲夏令时为UTC+2。

**UTC**

协调世界时，又称世界标准时间或世界协调时间，简称UTC，从英文“Coordinated Universal Time”／法文“Temps Universel Cordonné”而来。台湾采用CNS 7648的《资料元及交换格式–资讯交换–日期及时间的表示法》（与ISO 8601类似）称之为世界统一时间。中国大陆采用ISO 8601-1988的国标《数据元和交换格式信息交换日期和时间表示法》（GB/T 7408）中称之为国际协调时间。协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。

**GMT**

格林尼治标准时间（旧译格林尼治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。

**CST**

北京时间，China Standard Time，又名中国标准时间，是中国的标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8，与中华民国国家标准时间（旧称“中原标准时间”）、香港时间和澳门时间和相同。當格林威治時間為凌晨0:00時，中國標準時間剛好為上午8:00。

**关系**

CET=UTC/GMT + 1小时 CST=UTC/GMT +8 小时 CST=CET+9

#### SimpleDateFormat的线程安全性问题

在日常开发中，经常会用到时间，有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成需要的格式，最常用的方法就是使用SimpleDateFormat类。

- **SimpleDateFormat用法**

  SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。

  在Java中，可以使用SimpleDateFormat的format方法，将一个Date类型转化成String类型，并且可以指定输出格式。

  ```java
  // Date转String
  Date date = new Date();
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  String dateStr = sdf.format(date);
  System.out.println(dateStr);
  ```

  转换结果：

  ```
  2018-11-25 13:00:00
  ```

  日期和时间格式由"日期和时间模式"字符串指定。

  在Java中，可以使用SimpleDateFormat的parse方法，将一个String类型转化成Date类型。

  ```java
  // String转Data
  System.out.println(sdf.parse(dateStr));
  ```

- **日期和时间模式表达方法**

  在使用SimpleDateFormat的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表如下：

  <img src="https://www.hollischuang.com/wp-content/uploads/2018/11/15431240092595.jpg" />

  模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表示方法。

  <img src="https://www.hollischuang.com/wp-content/uploads/2018/11/15431240361504.jpg" />

- **输出不同时区的时间**

  时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。

  世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。

  现今全球共分为24个时区。由于实用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。

  由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一样，所以，在Java中想要获取时间的时候，要重点关注一下时区问题。

  默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么通过只要使用`new Date()`就可以获取中国的当前时间的原因。

  那么，如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。

  ```java
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  sdf.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));
  System.out.println(sdf.format(Calendar.getInstance().getTime()));
  ```

  转换结果：

  ```
  2018-11-24 21:00:00
  ```

  既中国的时间是11月25日的13点，而美国洛杉矶时间比中国北京时间慢了16个小时。

  > 尝试打印一下美国纽约时间（America/New_York）
  >
  > 纽约时间是2018-11-25 00:00:00
  >
  > 纽约时间比中国北京时间早了13个小时

- **SimpleDateFormat线程安全性**

  由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：

  ```java
  public class Main {
      
      private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  
      public static void main(String[] args) {
          simpleDateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
          System.out.println(simpleDateFormat.format(Calendar.getInstance().getTime()));
      }
  }
  ```

  *这种定义方式，存在很大的安全隐患。*

- **问题重现**

  来看一段代码，以下代码使用线程池来执行时间输出。

  ```java
  public class Main {
      //定义一个全局的SimpleDateFormat
      private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  
      //使用ThreadFactoryBuilder定义一个线程池
      private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
              .setNameFormat("demo-pool-%d").build();
  
      private static ExecutorService pool = new ThreadPoolExecutor(5, 200,
              0L, TimeUnit.MILLISECONDS,
              new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());
  
      //定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行
      private static CountDownLatch countDownLatch = new CountDownLatch(100);
  
      public static void main(String[] args) {
          //定义一个线程安全的HashSet
          Set<String> dates = Collections.synchronizedSet(new HashSet<String>());
          for (int i = 0; i < 100; i++) {
              //获取当前时间
              Calendar calendar = Calendar.getInstance();
              int finalI = i;
              pool.execute(() -> {
                  //时间增加
                  calendar.add(Calendar.DATE, finalI);
                  //通过simpleDateFormat把时间转换成字符串
                  String dateString = simpleDateFormat.format(calendar.getTime());
                  //把字符串放入Set中
                  dates.add(dateString);
                  //countDown
                  countDownLatch.countDown();
              });
          }
          //阻塞，直到countDown数量为0
          countDownLatch.await();
          //输出去重后的时间个数
          System.out.println(dates.size());
      }
  }
  ```
  
  以上代码就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个**线程安全**、**带有去重功能**的Set中，然后输出Set中元素个数。
  
  正常情况下，以上代码输出结果应该是100，但是实际执行结果是一个小于100的数字。
  
  原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。
  
  在阿里巴巴Java开发手册有明确说明：

  <img src="https://www.hollischuang.com/wp-content/uploads/2018/11/guiyue2.png" />

- **线程不安全原因**

  通过以上代码，发现在并发场景中使用SimpleDateFormat会有线程安全问题。

  JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：

  > Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.

  那么接下来分析下为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？

  跟一下SimpleDateFormat类中format方法的实现其实就能发现端倪。

  <img src="https://www.hollischuang.com/wp-content/uploads/2018/11/15431313894397.jpg" />

  SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。

  由于在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。

  假设线程1刚刚执行完`calendar.setTime`把时间设置成2018-11-11，还没等执行完，线程2又执行了`calendar.setTime`把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的`calendar.getTime`得到的时间就是线程2改过之后的。

  除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。

  所以，不要把SimpleDateFormat作为一个共享变量使用。	

- **如何解决**

  前面介绍过了SimpleDateFormat存在的问题以及问题存在的原因，那么有什么办法解决这种问题呢？

  解决方法有很多，这里介绍三个比较常用的方法。

  **使用局部变量**

  ```java
  for (int i = 0; i < 100; i++) {
      //获取当前时间
      Calendar calendar = Calendar.getInstance();
      int finalI = i;
      pool.execute(() -> {
          // SimpleDateFormat声明成局部变量
      SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
          //时间增加
          calendar.add(Calendar.DATE, finalI);
          //通过simpleDateFormat把时间转换成字符串
          String dateString = simpleDateFormat.format(calendar.getTime());
          //把字符串放入Set中
          dates.add(dateString);
          //countDown
          countDownLatch.countDown();
      });
  }
  ```

  SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。

  **加同步锁**

  除了改成局部变量以外，还有一种方法大家可能比较熟悉的，就是对于共享变量进行加锁。

  ```java
  for (int i = 0; i < 100; i++) {
      //获取当前时间
      Calendar calendar = Calendar.getInstance();
      int finalI = i;
      pool.execute(() -> {
          //加锁j
          synchronized (simpleDateFormat) {
              //时间增加
              calendar.add(Calendar.DATE, finalI);
              //通过simpleDateFormat把时间转换成字符串
              String dateString = simpleDateFormat.format(calendar.getTime());
              //把字符串放入Set中
              dates.add(dateString);
              //countDown
              countDownLatch.countDown();
          }
      });
  }
  ```

  通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。

  其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以只对`simpleDateFormat.format`这一行加锁，这样效率更高一些。

  **使用ThreadLocal**

  第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。

  ```java
  /**
   * 使用ThreadLocal定义一个全局的SimpleDateFormat
   */
  private static ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      }
  };
  
  //用法
  String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());
  ```

  用 ThreadLocal 来实现其实是有点类似于缓存的思路，每个线程都有一个独享的对象，避免了频繁创建对象，也避免了多线程的竞争。

  当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。

  **使用DateTimeFormatter**

  如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。

  ```java
  //解析日期
  String dateStr= "2016年10月25日";
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日");
  LocalDate date= LocalDate.parse(dateStr, formatter);
  
  //日期转换为字符串
  LocalDateTime now = LocalDateTime.now();
  DateTimeFormatter format = DateTimeFormatter.ofPattern("yyyy年MM月dd日 hh:mm a");
  String nowStr = now .format(format);
  System.out.println(nowStr);
  ```

- **总结**

  本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。

  主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个等。

#### Java 8中的时间处理

Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。

在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：

- 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。
- 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。
- 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。

在Java8中， 新的时间及⽇期API位于java.time包中， 该包中有哪些重要的类。 分别代表了什么？

`Instant`： 时间戳

`Duration`： 持续时间， 时间差

`LocalDate`： 只包含⽇期， ⽐如： 2016-10-20

`LocalTime`： 只包含时间， ⽐如： 23:12:10

`LocalDateTime`： 包含⽇期和时间， ⽐如： 2016-10-20 23:14:21

`Period`： 时间段

`ZoneOffset`： 时区偏移量， ⽐如： +8:00

`ZonedDateTime`： 带时区的时间

`Clock`： 时钟， ⽐如获取⽬前美国纽约的时间

新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。

**LocalTime 和 LocalDate的区别？**

`LocalDate`表⽰⽇期，年⽉⽇，`LocalTime`表⽰时间，时分秒

**获取当前时间**

```java
LocalDate today = LocalDate.now();
int year = today.getYear();
int month = today.getMonthValue();
int day = today.getDayOfMonth();
System.out.printf("Year : %d Month : %d day : %d t %n", year,month, day);
```

**创建指定日期的时间**

```java
LocalDate date = LocalDate.of(2018, 01, 01);
```

**检查闰年**

直接使⽤LocalDate的isLeapYear即可判断是否闰年

```java
LocalDate nowDate = LocalDate.now();
//判断闰年
boolean leapYear = nowDate.isLeapYear();
```

**计算两个日期之间的天数和月数**

在Java 8中可以⽤java.time.Period类来做计算。

```java
Period period = Period.between(LocalDate.of(2018, 1, 5),LocalDate.of(2018, 2, 5));
```

**字符串日期互转**

```java
LocalDateTime now = LocalDateTime.now();
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String strNow = now.format(formatter);
System.out.println("日期转字符串：" + strNow);
System.out.println("字符串转日期：" + LocalDateTime.parse(strNow, formatter));
```

#### 如何在东八区的计算机上获取美国时间

#### yyyy和YYYY有什么区别？

在使用SimpleDateFormat的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表(JDK 1.8)如下：

![](http://www.hollischuang.com/wp-content/uploads/2020/01/15781278483147.jpg)

可以看到，*y表示Year ,而Y表示Week Year*

**什么是Week Year**

不同的国家对于一周的开始和结束的定义是不同的。如在中国，把星期一作为一周的第一天，而在美国，他们把星期日作为一周的第一天。

同样，如何定义哪一周是一年当中的第一周？这也是一个问题，有很多种方式。

比如下图是2019年12月-2020年1月的一份日历。

![](http://www.hollischuang.com/wp-content/uploads/2020/01/15781286552869.jpg)

到底哪一周才算2020年的第一周呢？不同的地区和国家，甚至不同的人，都有不同的理解。

* 1月1日是周三，到下周三（1月8日），这7天算作这一年的第一周。
* 因为周日（周一）才是一周的第一天，所以，要从2020年的第一个周日（周一）开始往后推7天才算这一年的第一周。
* 因为12.29、12.30、12.31是2019年，而1.1、1.2、1.3才是2020年，而1.4周日是下一周的开始，所以，第一周应该只有1.1、1.2、1.3这三天。

**ISO 8601**

因为不同人对于日期和时间的表示方法有不同的理解，于是，大家就共同制定了了一个国际规范：ISO 8601 。

国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。

在 ISO 8601中。对于一年的第一个日历星期有以下四种等效说法： 

* 本年度第一个星期四所在的星期； 
* 1月4日所在的星期； 
* 本年度第一个至少有4天在同一星期内的星期； 
* 星期一在去年12月29日至今年1月4日以内的星期；

根据这个标准，可以推算出：

2020年第一周：2019.12.29-2020.1.4

所以，根据ISO 8601标准，2019年12月29日、2019年12月30日、2019年12月31日这两天，其实不属于2019年的最后一周，而是属于2020年的第一周。

**JDK针对ISO 8601提供的支持**

根据ISO 8601中关于日历星期和日表示法的定义，2019.12.29-2020.1.4是2020年的第一周。

希望输入一个日期，然后程序告诉我们，根据ISO 8601中关于日历日期的定义，这个日期到底属于哪一年。

比如我输入2019-12-20，他告诉我是2019；而我输入2019-12-30的时候，他告诉我是2020。

为了提供这样的数据，Java 7引入了「YYYY」作为一个新的日期模式来作为标识。使用「YYYY」作为标识，。再通过SimpleDateFormat就可以得到一个日期所属的周属于哪一年了


所以，要表示日期的时候，一定要使用 yyyy-MM-dd 而不是 YYYY-MM-dd ，这两者的返回结果大多数情况下都一样，但是极端情况就会有问题了。

### 编码方式

#### 什么是ASCII？

#### 什么是Unicode？

#### 有了Unicode为啥还需要UTF-8

#### UTF8、UTF16、UTF32区别

#### GBK、GB2312、GB18030之间的区别

#### URL编解码

#### Big Endian和Little Endian

### 语法糖

### lambda表达式

## Java 并发编程

### 并发与并行

### 线程

### 创建线程的多种方式

### 线程池

### 线程安全

### 锁

### 无锁

### 锁优化

### 死锁

### synchronized

### volatile

### 线程相关方法

### ThreadLocal

### 写代码来解决生产者消费者问题

### 并发包

<RightMenu />