---
title: 数据结构
---

# 数据结构

## 什么是数据结构？

[数据](https://baike.baidu.com/item/数据/5947370)结构是[计算机](https://baike.baidu.com/item/计算机/140338)存储、组织[数据](https://baike.baidu.com/item/数据)的方式。数据结构是指相互之间存在一种或多种特定关系的[数据元素](https://baike.baidu.com/item/数据元素/715313)的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储[效率](https://baike.baidu.com/item/效率/868847)。数据结构往往同高效的检索[算法](https://baike.baidu.com/item/算法/209025)和[索引](https://baike.baidu.com/item/索引/5716853)技术有关。

数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的[逻辑结构](https://baike.baidu.com/item/逻辑结构/9663235)和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的[存储结构](https://baike.baidu.com/item/存储结构/350782)。

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。

## 研究对象？

### 数据的逻辑结构

指反映数据[元素](https://baike.baidu.com/item/元素)之间的逻辑关系的[数据结构](https://baike.baidu.com/item/数据结构)，其中的[逻辑关系](https://baike.baidu.com/item/逻辑关系)是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。

逻辑结构包括： 

1. 集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；

2. 线性结构：数据结构中的元素存在一对一的相互关系；

3. [树形结构](https://baike.baidu.com/item/树形结构)：数据结构中的元素存在一对多的相互关系；

4. [图形结构](https://baike.baidu.com/item/图形结构)：数据结构中的元素存在多对多的相互关系。 

### 数据的物理结构

指数据的[逻辑结构](https://baike.baidu.com/item/逻辑结构)在计算机存储空间的存放形式。

数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。 

数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）。

关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系。

### 数据存储结构

数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。 [4] 

数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系。

## 数据结构的分类

数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括线性结构和非线性结构两类。

### 线性结构

简单地说，线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

1. 线性结构是非空集。

2. 线性结构有且仅有一个开始结点和一个终端结点。

3. 线性结构所有结点都最多只有一个直接前趋结点和一个直接后继结点。

线性表就是典型的线性结构，还有栈、队列和串等都属于线性结构。

### 非线性结构

简单地说，非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点： [5] 

1. 非线性结构是非空集。 

2. 非线性结构的一个结点可能有多个直接前趋结点和多个直接后继结点。

在实际应用中，数组、广义表、树结构和图结构等数据结构都属于非线性结构。

## 常用的数据结构

### 数组(Array)

[数组](https://baike.baidu.com/item/数组/3794097)是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。

**数组基础**

- 把数据码成一排进行排放
- 数组最大的优点：快速查询
- 数组最好应用于“索引有语意”的情况
- 但并非所有有语意的索引都适用于数组
- 数组也可以处理“索引没有语意”的情况

**动态数组**

### 栈(Stack)

[栈](https://baike.baidu.com/item/栈/12808149)是一种特殊的[线性表](https://baike.baidu.com/item/线性表/3228081)。

**栈的定义**

- 栈也是一种线性结构
- 相比数组，栈对应的操作是数组的子集
- 只能从一端添加元素，也只能从一端取出元素，这一端称为栈顶
- 栈中没有数据时，称为空栈
- 栈是一种后进先出的数据结构
- Last In First Out（LIFO）

**栈的应用**

- 无处不在的Undo操作（撤销）
- 程序调用的系统栈
- 括号匹配

**栈的实现**

**栈的复杂度分析**

```java
void push(E) ：O(1) 均摊
E pop()：O(1) 均摊
E peek()：O(1)
int getSize()：O(1)
boolean isEmpty()：O(1)
```

### 队列(Queue)

[队列](https://baike.baidu.com/item/队列/14580481)和栈类似，也是一种特殊的线性表。

**队列的定义**

- 队列也是一种线性结构
- 相比数组，队列对应的操作是数组的子集
- 只能从一端（队尾）添加元素，也只能从另一端（队尾）取出元素
- 队列是一种先进先出的数据结构（先到先得）
- 队列中没有元素时，称为空队列
- First In First Out（FIFO）

**队列的实现**

**数组队列的复杂度分析**

```java
void enqueue(E) ：O(1) 均摊
E dequeue() ：O(n) 
E getFront() ：O(1) 
int getSize() ：O(1) 
boolean isEmpty() ：O(1) 
```

**数组队列的问题**

**循环队列的复杂度分析**

```java
void enqueue(E) ：O(1) 均摊
E dequeue() ：O(1) 均摊
E getFront() ：O(1)
int getSize() ：O(1) 
boolean isEmpty() ：O(1) 
```

**优先队列**

出队顺序和入队顺序无关，和优先级有关

|              | 入队    | 出队（拿出最大元素） |
| ------------ | ------- | -------------------- |
| 普通线性结构 | O(1)    | O(n)                 |
| 顺序线性结构 | O(n)    | O(1)                 |
| 堆           | O(logn) | O(logn)              |

### 链表(LinkedList)

[链表](https://baike.baidu.com/item/链表/9794473)是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

**数据存储在"节点"（Node）中**

```java
class Node {
	E e;
	Node next;
}
```

**数组和链表的对比**

- 数组最好用于索引有语意的情况
- 最大的优点：支持快速查询
- 链表不适合用于索引有语意的情况
- 最大的优点：动态

**链表的时间复杂度分析**

- 添加操作：O(n)
  ```java
  addLast(e)：O(n)
  addFirst(e)：O(1)
  add(index, e)：O(n/2) = O(n)
  ```

- 删除操作：O(n)
  ```java
  removeLast(e)：O(n)
  removeFirst(e)：O(1)
  remove(index, e)：O(n/2) = O(n)
  ```

- 修改操作：O(n)

  ```java
  set(index, e)：O(n)
  ```

- 查找操作：O(n)
  ```java
  get(index)：O(n)
  contains(e)：O(n)
  ```

**使用链表实现栈**

**使用链表实现队列**

### 树(Tree)

[树](https://baike.baidu.com/item/树/2699484)是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。

<img src="https://s1.ax1x.com/2020/10/11/0chAUJ.png" alt="0cyMzF.png" />

为什么要有树结构？

将数据使用树结构存储后，出奇的高效。

#### 二叉树

和链表一样，是动态数据结构

```java
class Node {
	E e;
	Node left;//左孩子
	Node right;//右孩子
}
```

- 具有唯一根节点
- 每个节点最有有两个孩子
- 每个节点最多只有一个父亲
- 具有天然递归结构
- 每个节点的左子树也是二叉树
- 每个节点的又子树也是二叉树
- 二叉树不一定是“满” 的
- 一个节点也是二叉树
- 空也是二叉树

**二分搜索树（Binary Serach Tree）**

- 二分搜索树是二叉树
- 二分搜索树的每个节点的值
  - 大于其左子树的所有节点的值
  - 小于其右子树的所有节点的值
- 每一颗子树也是二分搜索树
- 存储的元素必须有可比较性

**前序遍历**

**中序遍历**

二分搜索树的中序遍历结果是顺序的

**后序遍历**

后续遍历的一个应用：为二分搜索树释放内存

#### **线段树**

**为什么使用线段树？**

对于有一类问题，关心的是线段（或者区间）

最经典的线段树问题：区间染色

有一面墙，长度为n，每次选择一段儿墙进行染色

<img src="https://s1.ax1x.com/2020/10/31/BaQuCT.png" />

m次操作后，可以看见多少种颜色？

m次操作后，可以在[i, j]区间内看见多少种颜色？

|                      | 使用数组实现 |
| -------------------- | ------------ |
| 染色操作（更新区间） | O(n)         |
| 查询操作（查询区间） | O(n)         |

另一类经典问题：区间查询

<img src="https://s1.ax1x.com/2020/10/31/BaQyVI.png" />

对于给定区间：

更新：更新区间中一个元素或者一个区间的值

查询：查询一个区间[i, j]的最大值，最小值，或者区间数字和

实质：基本区间的统计查询

|      | 使用数组实现 | 使用线段树 |
| ---- | ------------ | ---------- |
| 更新 | O(n)         | O(logn)    |
| 查询 | O(n)         | O(logn)    |

**什么是线段树？**

<img src="https://s1.ax1x.com/2020/10/31/BaDVld.png" />

线段树是一个平衡二叉树，但不一定是完全二叉树

如果区间有n个元素，数组表示需要有多少节点？

看作满二叉树，对满二叉树：

h层，一共有2^h-1个节点（大约是2^h）

最后一层（h-1层），有2^(h-1)个节点

最后一层的节点数大致等于前面所有层节点之和

需要4n的空间

#### Trie

**什么是Trie？**

Trie 又称字典树或前缀树，是一个用于处理多模式字符串匹配的多叉树，用来在一组字符串中快速的找到某个字符串。

其本质就是共享字符串的公共前缀，即利用字符串之间的公共前缀**，**将重复的前缀合并在一起**。**

<img src="https://s3.ax1x.com/2020/11/14/DCE141.png" />

Trie查找每个条目的时间复杂度和字典中一共有多少条目无关

Trie查找速度主要和它的元素（字符串）的长度相关[O(w)]，w为查询单词的长度

每个节点有若干个指向下个节点的指针

```java
class Node {
    boolean isWord;
    Map<char, Node> next;
}
```

#### 并查集

并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题，常常在使用中以森林来表示。

**主要操作**

- 初始化

  > 把每个点所在集合初始化为其自身。
  >
  > 通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。

- 查找

  > 查找元素所在的集合，即根节点。

- 合并

  > 将两个元素所在的集合合并为一个集合。
  >
  > 通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。

**优化路径压缩**

- 找到根结点。
- 修改查找路径上的所有节点，将它们都指向根结点。

**并查集的时间复杂度分析**

<img src="https://s3.ax1x.com/2020/11/22/DG1UzV.jpg" />

### 图(Graph)

[图](https://baike.baidu.com/item/图/13018767)是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

### 堆(Heap)

[堆](https://baike.baidu.com/item/堆/20606834)是一种特殊的树形数据结构，堆也是平衡二叉树，一般讨论的堆都是二叉堆。

堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。

**二叉堆（Binary Heap）**

<img src="https://s1.ax1x.com/2020/10/25/BmRyr9.png" />

二叉堆是一颗完全二叉树（把元素顺序排列成树的结构）

堆中某个节点的值总是不大于其父节点的值

最大堆（相应的可以定义最小堆）

用数组存储二叉堆

堆的时间复杂度分析

> add 和 extractMax 时间复杂度都是O(logn)

### 散列表(Hash)

散列表源自于[散列函数](https://baike.baidu.com/item/散列函数/2366288)(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

### 集合和映射(Set and Map)

#### Set

Set特点：元素无放入顺序，元素不可重复。

典型应用：客户统计和词汇量统计

```java
void add(E);
void remove(E);
boolean contains(E);
int getSize();
boolean isEmpty();
```

<center>集合的时间复杂度分析</center>

|   method    | LinkedListSet | BSTSet |  平均   | 最差 |
| :---------: | :-----------: | :----: | :-----: | :--: |
|   增 add    |     O(n)      |  O(h)  | O(logn) | O(n) |
|  删 remove  |     O(n)      |  O(h)  | O(logn) | O(n) |
| 查 contains |     O(n)      |  O(h)  | O(logn) | O(n) |

<div>
    <img src="https://s1.ax1x.com/2020/10/24/BV8yfe.png" style="zoom: 50%;" />
    <img src="https://s1.ax1x.com/2020/10/24/BVJ7ss.png" />
</div>

*二分搜索树可能退化成链表*

**有序映射和无序映射**

- 有序映射中的键具有顺序性：基于搜索树的实现
- 无序映射中的键没有顺序性：基于哈希表的实现

#### Map

<img src="https://s1.ax1x.com/2020/10/24/BVwGYq.png" />

- 存储（键，值）数据对的数据结构（Key, Value）

- 根据键（Key），寻找值（Value）

- 非常容易使用链表或者二分搜索树实现

  ```java
  //二分搜索树
  class Node {
      K key;
      V value;
      Node left;
      Node right;
  }
  
  //链表
  class Node {
      K key;
      V value;
      Node next;
  }
  ```

<center>映射的时间复杂度分析</center>

|   method    | LinkedListMap | BSTMap |  平均   | 最差 |
| :---------: | :-----------: | :----: | :-----: | :--: |
|   增 add    |     O(n)      |  O(h)  | O(logn) | O(n) |
|  删 remove  |     O(n)      |  O(h)  | O(logn) | O(n) |
| 查 contains |     O(n)      |  O(h)  | O(logn) | O(n) |
|   查 get    |     O(n)      |  O(h)  | O(logn) | O(n) |
|   改 set    |     O(n)      |  O(h)  | O(logn) | O(n) |

**有序集合和无序集合**

- 有序集合中的元素具有顺序性：基于搜索树的实现
- 无序集合中的元素没有顺序性：基于哈希表的实现

## 数据结构的应用

1. 数据库
2. 操作系统
3. 文件压缩：哈弗曼树
4. 通讯录：Trie - 前缀

## 递归

- 本质上，将原来的问题，转化为更小的问题

- 举例：数组求和

  > Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])
  >
  > Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])
  >
  > ......
  >
  > Sum(arr[n-1...n-1]) = arr[n-1] + Sum(arr[n...n-1])
  

<img src="https://s1.ax1x.com/2020/10/11/0csc2F.png" />

<RightMenu />